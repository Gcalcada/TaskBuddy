"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeDataScrubber = exports.subscribeTelemetry = void 0;
const apple_utils_1 = require("@expo/apple-utils");
const uuid_1 = require("uuid");
/**
 * Subscribe the telemetry to the ongoing metadata requests and responses.
 * When providing the app and auth info, we can scrub that data from the telemetry.
 * Returns an execution ID to group all events of a single run together, and a unsubscribe function.
 */
function subscribeTelemetry(analytics, event, options) {
    const executionId = (0, uuid_1.v4)();
    const scrubber = makeDataScrubber(options);
    const { interceptors } = (0, apple_utils_1.getRequestClient)();
    const responseInterceptorId = interceptors.response.use(response => {
        analytics.logEvent(event, {
            executionId,
            type: 'response',
            phase: 'resolved',
            method: response.request.method.toUpperCase(),
            url: scrubber(response.request.path),
            status: String(response.status),
            statusText: scrubber(response.statusText),
        });
        return response;
    }, (error) => {
        var _a, _b, _c, _d, _e;
        analytics.logEvent(event, {
            executionId,
            type: 'response',
            phase: 'rejected',
            method: error.request.method.toUpperCase(),
            url: scrubber((_a = error.config) === null || _a === void 0 ? void 0 : _a.url),
            error: scrubber(error.message),
            status: String((_b = error.response) === null || _b === void 0 ? void 0 : _b.status),
            statusText: scrubber((_c = error.response) === null || _c === void 0 ? void 0 : _c.statusText),
            input: scrubber((_d = error.config) === null || _d === void 0 ? void 0 : _d.data),
            output: scrubber((_e = error.response) === null || _e === void 0 ? void 0 : _e.data),
        });
        throw error;
    });
    function unsubscribeTelemetry() {
        interceptors.response.eject(responseInterceptorId);
    }
    return { unsubscribeTelemetry, executionId };
}
exports.subscribeTelemetry = subscribeTelemetry;
/** Exposed for testing */
function makeDataScrubber({ app, auth }) {
    var _a, _b;
    const token = getAuthTokenString(auth);
    const patterns = {
        APPLE_APP_ID: new RegExp(app.id, 'gi'),
        APPLE_USERNAME: auth.username ? new RegExp(auth.username, 'gi') : null,
        APPLE_PASSWORD: auth.password ? new RegExp(auth.password, 'gi') : null,
        APPLE_TOKEN: token ? new RegExp(token, 'gi') : null,
        APPLE_TEAM_ID: ((_a = auth.context) === null || _a === void 0 ? void 0 : _a.teamId) ? new RegExp(auth.context.teamId, 'gi') : null,
        APPLE_PROVIDER_ID: ((_b = auth.context) === null || _b === void 0 ? void 0 : _b.providerId)
            ? new RegExp(String(auth.context.providerId), 'gi')
            : null,
    };
    const iterator = Object.entries(patterns);
    return function scrubber(data) {
        if (!data) {
            return String(data);
        }
        let value = typeof data === 'object' ? JSON.stringify(data) : String(data);
        for (const [replacement, pattern] of iterator) {
            if (pattern) {
                value = value.replace(pattern, `{${replacement}}`);
            }
        }
        return value;
    };
}
exports.makeDataScrubber = makeDataScrubber;
function getAuthTokenString(auth) {
    var _a;
    if (!((_a = auth.context) === null || _a === void 0 ? void 0 : _a.token)) {
        return null;
    }
    if (typeof auth.context.token === 'object') {
        return auth.context.token.getToken();
    }
    return auth.context.token;
}
