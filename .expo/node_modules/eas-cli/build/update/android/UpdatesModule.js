"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readChannelSafelyAsync = exports.readReleaseChannelSafelyAsync = exports.syncUpdatesConfigurationAsync = void 0;
const config_plugins_1 = require("@expo/config-plugins");
const platform_1 = require("../../platform");
const projectUtils_1 = require("../../project/projectUtils");
const expoUpdatesCli_1 = require("../../utils/expoUpdatesCli");
const utils_1 = require("../utils");
/**
 * Synchronize updates configuration to native files. This needs to do essentially the same thing as `withUpdates`
 */
async function syncUpdatesConfigurationAsync(projectDir, exp) {
    (0, utils_1.ensureValidVersions)(exp, platform_1.RequestedPlatform.Android);
    if (await (0, projectUtils_1.isModernExpoUpdatesCLIWithRuntimeVersionCommandSupportedAsync)(projectDir)) {
        await (0, expoUpdatesCli_1.expoUpdatesCommandAsync)(projectDir, [
            'configuration:syncnative',
            '--platform',
            'android',
        ]);
        return;
    }
    // sync AndroidManifest.xml
    const androidManifestPath = await config_plugins_1.AndroidConfig.Paths.getAndroidManifestAsync(projectDir);
    const androidManifest = await getAndroidManifestAsync(projectDir);
    const updatedAndroidManifest = await config_plugins_1.AndroidConfig.Updates.setUpdatesConfigAsync(projectDir, exp, androidManifest);
    await config_plugins_1.AndroidConfig.Manifest.writeAndroidManifestAsync(androidManifestPath, updatedAndroidManifest);
    // sync strings.xml
    const stringsJSONPath = await config_plugins_1.AndroidConfig.Strings.getProjectStringsXMLPathAsync(projectDir);
    const stringsResourceXML = await config_plugins_1.AndroidConfig.Resources.readResourcesXMLAsync({
        path: stringsJSONPath,
    });
    // TODO(wschurman): this dependency needs to be updated for fingerprint
    const updatedStringsResourceXML = await config_plugins_1.AndroidConfig.Updates.applyRuntimeVersionFromConfigForProjectRootAsync(projectDir, exp, stringsResourceXML);
    await config_plugins_1.XML.writeXMLAsync({ path: stringsJSONPath, xml: updatedStringsResourceXML });
}
exports.syncUpdatesConfigurationAsync = syncUpdatesConfigurationAsync;
async function readReleaseChannelSafelyAsync(projectDir) {
    try {
        const androidManifest = await getAndroidManifestAsync(projectDir);
        return config_plugins_1.AndroidConfig.Manifest.getMainApplicationMetaDataValue(androidManifest, config_plugins_1.AndroidConfig.Updates.Config.RELEASE_CHANNEL);
    }
    catch {
        return null;
    }
}
exports.readReleaseChannelSafelyAsync = readReleaseChannelSafelyAsync;
async function readChannelSafelyAsync(projectDir) {
    var _a;
    try {
        const androidManifest = await getAndroidManifestAsync(projectDir);
        const stringifiedRequestHeaders = config_plugins_1.AndroidConfig.Manifest.getMainApplicationMetaDataValue(androidManifest, config_plugins_1.AndroidConfig.Updates.Config.UPDATES_CONFIGURATION_REQUEST_HEADERS_KEY);
        if (!stringifiedRequestHeaders) {
            return null;
        }
        return (_a = JSON.parse(stringifiedRequestHeaders)['expo-channel-name']) !== null && _a !== void 0 ? _a : null;
    }
    catch {
        return null;
    }
}
exports.readChannelSafelyAsync = readChannelSafelyAsync;
async function getAndroidManifestAsync(projectDir) {
    const androidManifestPath = await config_plugins_1.AndroidConfig.Paths.getAndroidManifestAsync(projectDir);
    if (!androidManifestPath) {
        throw new Error(`Could not find AndroidManifest.xml in project directory: "${projectDir}"`);
    }
    return config_plugins_1.AndroidConfig.Manifest.readAndroidManifestAsync(androidManifestPath);
}
