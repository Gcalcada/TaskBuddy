"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphqlError = exports.withErrorHandlingAsync = exports.graphqlClient = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@urql/core");
Object.defineProperty(exports, "GraphqlError", { enumerable: true, get: function () { return core_1.CombinedError; } });
const exchange_retry_1 = require("@urql/exchange-retry");
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const api_1 = require("../api");
const fetch_1 = require("../fetch");
const log_1 = tslib_1.__importDefault(require("../log"));
const sessionStorage_1 = require("../user/sessionStorage");
exports.graphqlClient = (0, core_1.createClient)({
    url: (0, api_1.getExpoApiBaseUrl)() + '/graphql',
    exchanges: [
        core_1.dedupExchange,
        core_1.cacheExchange,
        (0, exchange_retry_1.retryExchange)({
            maxDelayMs: 4000,
            retryIf: (err, operation) => {
                return !!(err &&
                    !operation.context.noRetry &&
                    (err.networkError || err.graphQLErrors.some(e => { var _a; return (_a = e === null || e === void 0 ? void 0 : e.extensions) === null || _a === void 0 ? void 0 : _a.isTransient; })));
            },
        }),
        core_1.fetchExchange,
    ],
    // @ts-expect-error Type 'typeof fetch' is not assignable to type '(input: RequestInfo, init?: RequestInit | undefined) => Promise<Response>'.
    fetch: node_fetch_1.default,
    fetchOptions: () => {
        const headers = {};
        const token = (0, sessionStorage_1.getAccessToken)();
        if (token) {
            headers.authorization = `Bearer ${token}`;
        }
        const sessionSecret = (0, sessionStorage_1.getSessionSecret)();
        if (!token && sessionSecret) {
            headers['expo-session'] = sessionSecret;
        }
        return {
            ...(fetch_1.httpsProxyAgent ? { agent: fetch_1.httpsProxyAgent } : {}),
            headers,
        };
    },
});
async function withErrorHandlingAsync(promise) {
    const { data, error } = await promise;
    if (error) {
        if (error.graphQLErrors.some(e => { var _a; return (_a = e === null || e === void 0 ? void 0 : e.extensions) === null || _a === void 0 ? void 0 : _a.isTransient; })) {
            log_1.default.error(`We've encountered a transient error, please try again shortly.`);
        }
        throw error;
    }
    // Check for malformed response. This only checks the root query existence,
    // It doesn't affect returning responses with empty resultset.
    if (!data) {
        throw new Error('Returned query result data is null!');
    }
    return data;
}
exports.withErrorHandlingAsync = withErrorHandlingAsync;
