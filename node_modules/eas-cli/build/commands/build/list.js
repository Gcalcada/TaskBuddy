"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const config_1 = require("@expo/config");
const core_1 = require("@oclif/core");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const types_1 = require("../../build/types");
const formatBuild_1 = require("../../build/utils/formatBuild");
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const generated_1 = require("../../graphql/generated");
const BuildQuery_1 = require("../../graphql/queries/BuildQuery");
const log_1 = tslib_1.__importDefault(require("../../log"));
const ora_1 = require("../../ora");
const platform_1 = require("../../platform");
const projectUtils_1 = require("../../project/projectUtils");
const json_1 = require("../../utils/json");
class BuildList extends EasCommand_1.default {
    async runAsync() {
        const { flags } = await this.parse(BuildList);
        const { json, platform: requestedPlatform, status: buildStatus, distribution: buildDistribution, limit = 10, } = flags;
        if (json) {
            (0, json_1.enableJsonOutput)();
        }
        const platform = toAppPlatform(requestedPlatform);
        const graphqlBuildStatus = toGraphQLBuildStatus(buildStatus);
        const graphqlBuildDistribution = toGraphQLBuildDistribution(buildDistribution);
        const projectDir = await (0, projectUtils_1.findProjectRootAsync)();
        const { exp } = (0, config_1.getConfig)(projectDir, { skipSDKVersionRequirement: true });
        const projectId = await (0, projectUtils_1.getProjectIdAsync)(exp);
        const projectName = await (0, projectUtils_1.getProjectFullNameAsync)(exp);
        const spinner = (0, ora_1.ora)().start('Fetching the build list for the project…');
        try {
            const builds = await BuildQuery_1.BuildQuery.allForAppAsync(projectId, {
                limit,
                filter: {
                    platform,
                    status: graphqlBuildStatus,
                    distribution: graphqlBuildDistribution,
                    channel: flags.channel,
                    appVersion: flags.appVersion,
                    appBuildVersion: flags.appBuildVersion,
                    sdkVersion: flags.sdkVersion,
                    runtimeVersion: flags.runtimeVersion,
                    appIdentifier: flags.appIdentifier,
                    buildProfile: flags.buildProfile,
                    gitCommitHash: flags.gitCommitHash,
                },
            });
            if (builds.length) {
                if (platform || graphqlBuildStatus) {
                    spinner.succeed(`Showing ${builds.length} matching builds for the project ${projectName}`);
                }
                else {
                    spinner.succeed(`Showing last ${builds.length} builds for the project ${projectName}`);
                }
                if (json) {
                    (0, json_1.printJsonOnlyOutput)(builds);
                }
                else {
                    const list = builds
                        .map(build => (0, formatBuild_1.formatGraphQLBuild)(build))
                        .join(`\n\n${chalk_1.default.dim('———')}\n\n`);
                    log_1.default.log(`\n${list}`);
                }
            }
            else {
                spinner.fail(`Couldn't find any builds for the project ${projectName}`);
            }
        }
        catch (e) {
            spinner.fail(`Something went wrong and we couldn't fetch the build list ${projectName}`);
            throw e;
        }
    }
}
exports.default = BuildList;
BuildList.description = 'list all builds for your project';
BuildList.flags = {
    platform: core_1.Flags.enum({
        options: [platform_1.RequestedPlatform.All, platform_1.RequestedPlatform.Android, platform_1.RequestedPlatform.Ios],
    }),
    json: core_1.Flags.boolean({
        description: 'Enable JSON output, non-JSON messages will be printed to stderr',
    }),
    status: core_1.Flags.enum({
        options: [
            types_1.BuildStatus.NEW,
            types_1.BuildStatus.IN_QUEUE,
            types_1.BuildStatus.IN_PROGRESS,
            types_1.BuildStatus.ERRORED,
            types_1.BuildStatus.FINISHED,
            types_1.BuildStatus.CANCELED,
        ],
    }),
    distribution: core_1.Flags.enum({
        options: [
            types_1.BuildDistributionType.STORE,
            types_1.BuildDistributionType.INTERNAL,
            types_1.BuildDistributionType.SIMULATOR,
        ],
    }),
    channel: core_1.Flags.string(),
    appVersion: core_1.Flags.string(),
    appBuildVersion: core_1.Flags.string(),
    sdkVersion: core_1.Flags.string(),
    runtimeVersion: core_1.Flags.string(),
    appIdentifier: core_1.Flags.string(),
    buildProfile: core_1.Flags.string(),
    gitCommitHash: core_1.Flags.string(),
    limit: core_1.Flags.integer(),
};
const toAppPlatform = (requestedPlatform) => {
    if (!requestedPlatform || requestedPlatform === platform_1.RequestedPlatform.All) {
        return undefined;
    }
    else if (requestedPlatform === platform_1.RequestedPlatform.Android) {
        return generated_1.AppPlatform.Android;
    }
    else {
        return generated_1.AppPlatform.Ios;
    }
};
const toGraphQLBuildStatus = (buildStatus) => {
    if (!buildStatus) {
        return undefined;
    }
    else if (buildStatus === types_1.BuildStatus.NEW) {
        return generated_1.BuildStatus.New;
    }
    else if (buildStatus === types_1.BuildStatus.IN_QUEUE) {
        return generated_1.BuildStatus.InQueue;
    }
    else if (buildStatus === types_1.BuildStatus.IN_PROGRESS) {
        return generated_1.BuildStatus.InProgress;
    }
    else if (buildStatus === types_1.BuildStatus.ERRORED) {
        return generated_1.BuildStatus.Errored;
    }
    else if (buildStatus === types_1.BuildStatus.FINISHED) {
        return generated_1.BuildStatus.Finished;
    }
    else {
        return generated_1.BuildStatus.Canceled;
    }
};
const toGraphQLBuildDistribution = (buildDistribution) => {
    if (buildDistribution === types_1.BuildDistributionType.STORE) {
        return generated_1.DistributionType.Store;
    }
    else if (buildDistribution === types_1.BuildDistributionType.INTERNAL) {
        return generated_1.DistributionType.Internal;
    }
    else if (buildDistribution === types_1.BuildDistributionType.SIMULATOR) {
        return generated_1.DistributionType.Simulator;
    }
    else {
        return undefined;
    }
};
