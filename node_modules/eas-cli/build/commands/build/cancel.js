"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const config_1 = require("@expo/config");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const graphql_tag_1 = tslib_1.__importDefault(require("graphql-tag"));
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const client_1 = require("../../graphql/client");
const generated_1 = require("../../graphql/generated");
const BuildQuery_1 = require("../../graphql/queries/BuildQuery");
const log_1 = tslib_1.__importDefault(require("../../log"));
const ora_1 = require("../../ora");
const platform_1 = require("../../platform");
const projectUtils_1 = require("../../project/projectUtils");
const prompts_1 = require("../../prompts");
async function cancelBuildAsync(buildId) {
    const data = await (0, client_1.withErrorHandlingAsync)(client_1.graphqlClient
        .mutation((0, graphql_tag_1.default) `
          mutation CancelBuildMutation($buildId: ID!) {
            build(buildId: $buildId) {
              cancel {
                id
                status
              }
            }
          }
        `, { buildId })
        .toPromise());
    return data.build.cancel;
}
function formatUnfinishedBuild(build) {
    const platform = platform_1.appPlatformEmojis[build.platform];
    const startTime = new Date(build.createdAt).toLocaleString();
    let statusText;
    if (build.status === generated_1.BuildStatus.New) {
        statusText = 'new';
    }
    else if (build.status === generated_1.BuildStatus.InQueue) {
        statusText = 'in queue';
    }
    else {
        statusText = 'in progress';
    }
    const status = chalk_1.default.blue(statusText);
    return `${platform} Started at: ${startTime}, Status: ${status}, Id: ${build.id}`;
}
async function selectBuildToCancelAsync(projectId, projectFullName) {
    const spinner = (0, ora_1.ora)().start('Fetching the uncompleted builds…');
    let builds;
    try {
        const [newBuilds, inQueueBuilds, inProgressBuilds] = await Promise.all([
            BuildQuery_1.BuildQuery.allForAppAsync(projectId, { filter: { status: generated_1.BuildStatus.New } }),
            BuildQuery_1.BuildQuery.allForAppAsync(projectId, { filter: { status: generated_1.BuildStatus.InQueue } }),
            BuildQuery_1.BuildQuery.allForAppAsync(projectId, { filter: { status: generated_1.BuildStatus.InProgress } }),
        ]);
        spinner.stop();
        builds = [...newBuilds, ...inQueueBuilds, ...inProgressBuilds];
    }
    catch (error) {
        spinner.fail(`Something went wrong and we couldn't fetch the builds for the project ${projectFullName}.`);
        throw error;
    }
    if (builds.length === 0) {
        log_1.default.warn(`There aren't any uncompleted builds for the project ${projectFullName}.`);
        return null;
    }
    else if (builds.length === 1) {
        log_1.default.log('Found one build');
        log_1.default.log(formatUnfinishedBuild(builds[0]));
        await (0, prompts_1.confirmAsync)({
            message: 'Do you want to cancel it?',
        });
        return builds[0].id;
    }
    else {
        const buildId = await (0, prompts_1.selectAsync)('Which build do you want to cancel?', builds.map(build => ({
            title: formatUnfinishedBuild(build),
            value: build.id,
        })));
        return buildId;
    }
}
async function ensureBuildExistsAsync(buildId) {
    try {
        await BuildQuery_1.BuildQuery.byIdAsync(buildId);
    }
    catch (err) {
        throw new Error(`Couldn't find a build matching the id ${buildId}`);
    }
}
class BuildCancel extends EasCommand_1.default {
    async runAsync() {
        const { BUILD_ID: buildIdFromArg } = (await this.parse(BuildCancel)).args;
        const projectDir = await (0, projectUtils_1.findProjectRootAsync)();
        const { exp } = (0, config_1.getConfig)(projectDir, { skipSDKVersionRequirement: true });
        const projectId = await (0, projectUtils_1.getProjectIdAsync)(exp);
        const projectFullName = await (0, projectUtils_1.getProjectFullNameAsync)(exp);
        if (buildIdFromArg) {
            await ensureBuildExistsAsync(buildIdFromArg);
        }
        const buildId = buildIdFromArg || (await selectBuildToCancelAsync(projectId, projectFullName));
        if (!buildId) {
            return;
        }
        const spinner = (0, ora_1.ora)().start('Canceling the build…');
        try {
            const { status } = await cancelBuildAsync(buildId);
            if (status === generated_1.BuildStatus.Canceled) {
                spinner.succeed('Build canceled');
            }
            else {
                spinner.text = 'Build is already completed';
                spinner.stopAndPersist();
            }
        }
        catch (error) {
            spinner.fail(`Something went wrong and we couldn't cancel your build ${buildId}`);
            throw error;
        }
    }
}
exports.default = BuildCancel;
BuildCancel.description = 'cancel a build';
BuildCancel.args = [{ name: 'BUILD_ID' }];
