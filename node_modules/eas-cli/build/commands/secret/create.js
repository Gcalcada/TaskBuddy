"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const config_1 = require("@expo/config");
const core_1 = require("@oclif/core");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const EnvironmentSecretMutation_1 = require("../../graphql/mutations/EnvironmentSecretMutation");
const EnvironmentSecretsQuery_1 = require("../../graphql/queries/EnvironmentSecretsQuery");
const log_1 = tslib_1.__importDefault(require("../../log"));
const projectUtils_1 = require("../../project/projectUtils");
const prompts_1 = require("../../prompts");
const Account_1 = require("../../user/Account");
const User_1 = require("../../user/User");
const actions_1 = require("../../user/actions");
class EnvironmentSecretCreate extends EasCommand_1.default {
    async runAsync() {
        const actor = await (0, actions_1.ensureLoggedInAsync)();
        let { flags: { name, value: secretValue, scope, force }, } = await this.parse(EnvironmentSecretCreate);
        const projectDir = await (0, projectUtils_1.findProjectRootAsync)();
        const { exp } = (0, config_1.getConfig)(projectDir, { skipSDKVersionRequirement: true });
        const accountName = await (0, projectUtils_1.getProjectAccountNameAsync)(exp);
        const { slug } = exp;
        const projectId = await (0, projectUtils_1.getProjectIdAsync)(exp);
        if (!scope) {
            const validationMessage = 'Secret scope may not be empty.';
            ({ scope } = await (0, prompts_1.promptAsync)({
                type: 'select',
                name: 'scope',
                message: 'Where should this secret be used:',
                choices: [
                    { title: 'Account-wide', value: EnvironmentSecretsQuery_1.EnvironmentSecretScope.ACCOUNT },
                    { title: 'Project-specific', value: EnvironmentSecretsQuery_1.EnvironmentSecretScope.PROJECT },
                ],
                validate: value => (value ? true : validationMessage),
            }));
        }
        if (!name) {
            ({ name } = await (0, prompts_1.promptAsync)({
                type: 'text',
                name: 'name',
                message: `Secret name:`,
                validate: value => {
                    if (!value) {
                        return 'Secret name may not be empty.';
                    }
                    // this validation regex here is just to shorten the feedback loop
                    // the source of truth is in www's EnvironmentSecretValidator class
                    if (!value.match(/^\w+$/)) {
                        return 'Names may contain only letters, numbers, and underscores.';
                    }
                    return true;
                },
            }));
            if (!name) {
                throw new Error('Secret name may not be empty.');
            }
        }
        if (!secretValue) {
            const validationMessage = 'Secret value may not be empty.';
            ({ secretValue } = await (0, prompts_1.promptAsync)({
                type: 'text',
                name: 'secretValue',
                message: 'Secret value:',
                validate: value => (value ? true : validationMessage),
            }));
            if (!secretValue) {
                throw new Error(validationMessage);
            }
        }
        if (scope === EnvironmentSecretsQuery_1.EnvironmentSecretScope.PROJECT) {
            if (force) {
                const existingSecrets = await EnvironmentSecretsQuery_1.EnvironmentSecretsQuery.byAppIdAsync(projectId);
                const existingSecret = existingSecrets.find(secret => secret.name === name);
                if (existingSecret) {
                    await EnvironmentSecretMutation_1.EnvironmentSecretMutation.deleteAsync(existingSecret.id);
                    log_1.default.withTick(`Deleting existing secret ${chalk_1.default.bold(name)} on project ${chalk_1.default.bold(`@${accountName}/${slug}`)}.`);
                }
            }
            const secret = await EnvironmentSecretMutation_1.EnvironmentSecretMutation.createForAppAsync({ name, value: secretValue }, projectId);
            if (!secret) {
                throw new Error(`Could not create secret with name ${name} on project with id ${projectId}`);
            }
            log_1.default.withTick(`️Created a new secret ${chalk_1.default.bold(name)} on project ${chalk_1.default.bold(`@${accountName}/${slug}`)}.`);
        }
        else if (scope === EnvironmentSecretsQuery_1.EnvironmentSecretScope.ACCOUNT) {
            const ownerAccount = (0, Account_1.findAccountByName)(actor.accounts, accountName);
            if (!ownerAccount) {
                log_1.default.warn(`Your account (${(0, User_1.getActorDisplayName)(actor)}) doesn't have access to the ${chalk_1.default.bold(accountName)} account`);
                return;
            }
            if (force) {
                const existingSecrets = await EnvironmentSecretsQuery_1.EnvironmentSecretsQuery.byAccountNameAsync(ownerAccount.name);
                const existingSecret = existingSecrets.find(secret => secret.name === name);
                if (existingSecret) {
                    await EnvironmentSecretMutation_1.EnvironmentSecretMutation.deleteAsync(existingSecret.id);
                    log_1.default.withTick(`Deleting existing secret ${chalk_1.default.bold(name)} on account ${chalk_1.default.bold(ownerAccount.name)}.`);
                }
            }
            const secret = await EnvironmentSecretMutation_1.EnvironmentSecretMutation.createForAccountAsync({ name, value: secretValue }, ownerAccount.id);
            if (!secret) {
                throw new Error(`Could not create secret with name ${name} on account with id ${ownerAccount.id}`);
            }
            log_1.default.withTick(`️Created a new secret ${chalk_1.default.bold(name)} on account ${chalk_1.default.bold(ownerAccount.name)}.`);
        }
    }
}
exports.default = EnvironmentSecretCreate;
EnvironmentSecretCreate.description = 'create an environment secret on the current project or owner account';
EnvironmentSecretCreate.flags = {
    scope: core_1.Flags.enum({
        description: 'Scope for the secret',
        options: [EnvironmentSecretsQuery_1.EnvironmentSecretScope.ACCOUNT, EnvironmentSecretsQuery_1.EnvironmentSecretScope.PROJECT],
        default: EnvironmentSecretsQuery_1.EnvironmentSecretScope.PROJECT,
    }),
    name: core_1.Flags.string({
        description: 'Name of the secret',
    }),
    value: core_1.Flags.string({
        description: 'Value of the secret',
    }),
    force: core_1.Flags.boolean({
        description: 'Delete and recreate existing secrets',
        default: false,
    }),
};
