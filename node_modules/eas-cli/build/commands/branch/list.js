"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.listBranchesAsync = void 0;
const tslib_1 = require("tslib");
const config_1 = require("@expo/config");
const core_1 = require("@oclif/core");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const cli_table3_1 = tslib_1.__importDefault(require("cli-table3"));
const graphql_1 = require("graphql");
const graphql_tag_1 = tslib_1.__importDefault(require("graphql-tag"));
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const client_1 = require("../../graphql/client");
const UpdateBranch_1 = require("../../graphql/types/UpdateBranch");
const log_1 = tslib_1.__importDefault(require("../../log"));
const projectUtils_1 = require("../../project/projectUtils");
const utils_1 = require("../../update/utils");
const json_1 = require("../../utils/json");
const BRANCHES_LIMIT = 10000;
async function listBranchesAsync({ projectId, }) {
    var _a, _b;
    const data = await (0, client_1.withErrorHandlingAsync)(client_1.graphqlClient
        .query((0, graphql_tag_1.default) `
          query BranchesByAppQuery($appId: String!, $limit: Int!) {
            app {
              byId(appId: $appId) {
                id
                updateBranches(offset: 0, limit: $limit) {
                  id
                  ...UpdateBranchFragment
                }
              }
            }
          }
          ${(0, graphql_1.print)(UpdateBranch_1.UpdateBranchFragmentNode)}
        `, {
        appId: projectId,
        limit: BRANCHES_LIMIT,
    }, { additionalTypenames: ['UpdateBranch'] })
        .toPromise());
    return (_b = (_a = data === null || data === void 0 ? void 0 : data.app) === null || _a === void 0 ? void 0 : _a.byId.updateBranches) !== null && _b !== void 0 ? _b : [];
}
exports.listBranchesAsync = listBranchesAsync;
class BranchList extends EasCommand_1.default {
    async runAsync() {
        const { flags } = await this.parse(BranchList);
        if (flags.json) {
            (0, json_1.enableJsonOutput)();
        }
        const projectDir = await (0, projectUtils_1.findProjectRootAsync)();
        const { exp } = (0, config_1.getConfig)(projectDir, { skipSDKVersionRequirement: true });
        const projectId = await (0, projectUtils_1.getProjectIdAsync)(exp);
        const branches = await listBranchesAsync({ projectId });
        if (flags.json) {
            (0, json_1.printJsonOnlyOutput)(branches);
        }
        else {
            const table = new cli_table3_1.default({
                head: ['Branch', ...utils_1.UPDATE_COLUMNS],
                wordWrap: true,
            });
            table.push(...branches.map(branch => {
                var _a, _b, _c, _d, _e;
                return [
                    branch.name,
                    (0, utils_1.formatUpdate)(branch.updates[0]),
                    (_b = (_a = branch.updates[0]) === null || _a === void 0 ? void 0 : _a.runtimeVersion) !== null && _b !== void 0 ? _b : 'N/A',
                    (_d = (_c = branch.updates[0]) === null || _c === void 0 ? void 0 : _c.group) !== null && _d !== void 0 ? _d : 'N/A',
                    (0, utils_1.getPlatformsForGroup)({
                        updates: branch.updates,
                        group: (_e = branch.updates[0]) === null || _e === void 0 ? void 0 : _e.group,
                    }),
                ];
            }));
            log_1.default.addNewLineIfNone();
            log_1.default.log(chalk_1.default.bold('Branches with their most recent update group:'));
            log_1.default.log(table.toString());
            if (branches.length >= BRANCHES_LIMIT) {
                log_1.default.warn(`Showing first ${BRANCHES_LIMIT} branches, some results might be omitted.`);
            }
        }
    }
}
exports.default = BranchList;
BranchList.description = 'list all branches';
BranchList.flags = {
    json: core_1.Flags.boolean({
        description: 'return output as JSON',
        default: false,
    }),
};
