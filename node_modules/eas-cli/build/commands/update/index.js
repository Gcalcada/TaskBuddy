"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultPublishPlatforms = void 0;
const tslib_1 = require("tslib");
const config_1 = require("@expo/config");
const config_plugins_1 = require("@expo/config-plugins");
const eas_build_job_1 = require("@expo/eas-build-job");
const core_1 = require("@oclif/core");
const assert_1 = tslib_1.__importDefault(require("assert"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const dateformat_1 = tslib_1.__importDefault(require("dateformat"));
const graphql_tag_1 = tslib_1.__importDefault(require("graphql-tag"));
const nullthrows_1 = tslib_1.__importDefault(require("nullthrows"));
const api_1 = require("../../api");
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const fetch_1 = tslib_1.__importDefault(require("../../fetch"));
const client_1 = require("../../graphql/client");
const PublishMutation_1 = require("../../graphql/mutations/PublishMutation");
const UpdateQuery_1 = require("../../graphql/queries/UpdateQuery");
const log_1 = tslib_1.__importDefault(require("../../log"));
const ora_1 = require("../../ora");
const projectUtils_1 = require("../../project/projectUtils");
const publish_1 = require("../../project/publish");
const workflow_1 = require("../../project/workflow");
const prompts_1 = require("../../prompts");
const utils_1 = require("../../update/utils");
const code_signing_1 = require("../../utils/code-signing");
const uniqBy_1 = tslib_1.__importDefault(require("../../utils/expodash/uniqBy"));
const formatFields_1 = tslib_1.__importDefault(require("../../utils/formatFields"));
const json_1 = require("../../utils/json");
const vcs_1 = require("../../vcs");
const create_1 = require("../branch/create");
const list_1 = require("../branch/list");
const create_2 = require("../channel/create");
exports.defaultPublishPlatforms = ['android', 'ios'];
async function getUpdateGroupAsync({ group, }) {
    const { updatesByGroup } = await (0, client_1.withErrorHandlingAsync)(client_1.graphqlClient
        .query((0, graphql_tag_1.default) `
          query getUpdateGroupAsync($group: ID!) {
            updatesByGroup(group: $group) {
              id
              group
              runtimeVersion
              manifestFragment
              platform
              message
            }
          }
        `, {
        group,
    }, { additionalTypenames: ['Update'] })
        .toPromise());
    return updatesByGroup;
}
async function ensureChannelExistsAsync({ appId, branchId, channelName, }) {
    var _a;
    try {
        await (0, create_2.createUpdateChannelOnAppAsync)({
            appId,
            channelName,
            branchId,
        });
        log_1.default.withTick(`Created a channel: ${chalk_1.default.bold(channelName)} pointed at branch: ${chalk_1.default.bold(channelName)}.`);
    }
    catch (e) {
        const isIgnorableError = ((_a = e.graphQLErrors) === null || _a === void 0 ? void 0 : _a.length) === 1 &&
            e.graphQLErrors[0].extensions.errorCode === 'CHANNEL_ALREADY_EXISTS';
        if (!isIgnorableError) {
            throw e;
        }
    }
}
async function ensureBranchExistsAsync({ appId, name: branchName, }) {
    const { app } = await UpdateQuery_1.UpdateQuery.viewBranchAsync({
        appId,
        name: branchName,
    });
    const updateBranch = app === null || app === void 0 ? void 0 : app.byId.updateBranchByName;
    if (updateBranch) {
        const { id, updates } = updateBranch;
        await ensureChannelExistsAsync({ appId, branchId: id, channelName: branchName });
        return { id, updates };
    }
    const newUpdateBranch = await (0, create_1.createUpdateBranchOnAppAsync)({ appId, name: branchName });
    log_1.default.withTick(`Created branch: ${chalk_1.default.bold(branchName)}`);
    await ensureChannelExistsAsync({ appId, branchId: newUpdateBranch.id, channelName: branchName });
    return { id: newUpdateBranch.id, updates: [] };
}
class UpdatePublish extends EasCommand_1.default {
    async runAsync() {
        var _a, _b, _c;
        let { flags: { branch: branchName, json: jsonFlag, auto: autoFlag, message, republish, group, 'input-dir': inputDir, 'skip-bundler': skipBundler, platform, 'private-key-path': privateKeyPath, }, } = await this.parse(UpdatePublish);
        if (jsonFlag) {
            (0, json_1.enableJsonOutput)();
        }
        const platformFlag = platform;
        // If a group was specified, that means we are republishing it.
        republish = group ? true : republish;
        const projectDir = await (0, projectUtils_1.findProjectRootAsync)();
        const { exp } = (0, config_1.getConfig)(projectDir, {
            skipSDKVersionRequirement: true,
            isPublicConfig: true,
        });
        const codeSigningInfo = await (0, code_signing_1.getCodeSigningInfoAsync)(exp, privateKeyPath);
        if (!(0, projectUtils_1.isExpoUpdatesInstalledOrAvailable)(projectDir, exp.sdkVersion)) {
            const install = await (0, prompts_1.confirmAsync)({
                message: `You are creating an update which requires ${chalk_1.default.bold('expo-updates')} to be installed in your app.\n  Do you want EAS CLI to install it for you?`,
                instructions: 'The command will abort unless you agree.',
            });
            if (install) {
                await (0, projectUtils_1.installExpoUpdatesAsync)(projectDir);
            }
            else {
                core_1.Errors.error(`Install ${chalk_1.default.bold('expo-updates')} manually and come back later.`, {
                    exit: 1,
                });
            }
        }
        const runtimeVersions = await getRuntimeVersionObjectAsync(exp, platformFlag, projectDir);
        const projectId = await (0, projectUtils_1.getProjectIdAsync)(exp);
        await checkEASUpdateURLIsSetAsync(exp);
        if (!branchName && autoFlag) {
            branchName =
                (await (0, vcs_1.getVcsClient)().getBranchNameAsync()) ||
                    `branch-${Math.random().toString(36).substr(2, 4)}`;
        }
        if (!branchName) {
            const validationMessage = 'Branch name may not be empty.';
            if (jsonFlag) {
                throw new Error(validationMessage);
            }
            const branches = await (0, list_1.listBranchesAsync)({ projectId });
            if (branches.length === 0) {
                ({ name: branchName } = await (0, prompts_1.promptAsync)({
                    type: 'text',
                    name: 'name',
                    message: 'No branches found. Creating a new one. Please name the new branch:',
                    initial: (await (0, vcs_1.getVcsClient)().getBranchNameAsync()) ||
                        `branch-${Math.random().toString(36).substr(2, 4)}`,
                    validate: value => (value ? true : validationMessage),
                }));
            }
            else {
                branchName = await (0, prompts_1.selectAsync)('Which branch would you like to publish on?', branches.map(branch => {
                    return {
                        title: `${branch.name} ${chalk_1.default.grey(`- current update: ${(0, utils_1.formatUpdate)(branch.updates[0])}`)}`,
                        value: branch.name,
                    };
                }));
            }
            (0, assert_1.default)(branchName, 'Branch name must be specified.');
        }
        const { id: branchId, updates } = await ensureBranchExistsAsync({
            appId: projectId,
            name: branchName,
        });
        let unsortedUpdateInfoGroups = {};
        let oldMessage, oldRuntimeVersion;
        if (republish) {
            // If we are republishing, we don't need to worry about building the bundle or uploading the assets.
            // Instead we get the `updateInfoGroup` from the update we wish to republish.
            let updatesToRepublish;
            if (group) {
                updatesToRepublish = await getUpdateGroupAsync({ group });
            }
            else {
                // Drop into interactive mode if the user has not specified an update group to republish.
                if (jsonFlag) {
                    throw new Error('You must specify the update group to republish.');
                }
                const updateGroups = (0, uniqBy_1.default)(updates, u => u.group)
                    .filter(update => {
                    // Only show groups that have updates on the specified platform(s).
                    return platformFlag === 'all' || update.platform === platformFlag;
                })
                    .map(update => ({
                    title: formatUpdateTitle(update),
                    value: update.group,
                }));
                if (updateGroups.length === 0) {
                    throw new Error(`There are no updates on branch "${branchName}" published on the platform(s) ${platformFlag}. Did you mean to publish a new update instead?`);
                }
                const selectedUpdateGroup = await (0, prompts_1.selectAsync)('which update would you like to republish?', updateGroups);
                updatesToRepublish = updates.filter(update => update.group === selectedUpdateGroup);
            }
            const updatesToRepublishFilteredByPlatform = updatesToRepublish.filter(
            // Only republish to the specified platforms
            update => platformFlag === 'all' || update.platform === platformFlag);
            if (updatesToRepublishFilteredByPlatform.length === 0) {
                throw new Error(`There are no updates on branch "${branchName}" published on the platform(s) "${platformFlag}" with group ID "${group ? group : updatesToRepublish[0].group}". Did you mean to publish a new update instead?`);
            }
            let publicationPlatformMessage;
            if (platformFlag === 'all') {
                if (updatesToRepublishFilteredByPlatform.length !== exports.defaultPublishPlatforms.length) {
                    log_1.default.warn(`You are republishing an update that wasn't published for all platforms.`);
                }
                publicationPlatformMessage = `The republished update will appear on the same plaforms it was originally published on: ${updatesToRepublishFilteredByPlatform
                    .map(update => update.platform)
                    .join(', ')}`;
            }
            else {
                publicationPlatformMessage = `The republished update will appear only on: ${platformFlag}`;
            }
            log_1.default.withTick(publicationPlatformMessage);
            for (const update of updatesToRepublishFilteredByPlatform) {
                const { manifestFragment } = update;
                const platform = update.platform;
                unsortedUpdateInfoGroups[platform] = JSON.parse(manifestFragment);
            }
            // These are the same for each member of an update group
            group = updatesToRepublishFilteredByPlatform[0].group;
            oldMessage = (_a = updatesToRepublishFilteredByPlatform[0].message) !== null && _a !== void 0 ? _a : '';
            oldRuntimeVersion = updatesToRepublishFilteredByPlatform[0].runtimeVersion;
            if (!message) {
                const validationMessage = 'publish message may not be empty.';
                if (jsonFlag) {
                    throw new Error(validationMessage);
                }
                ({ publishMessage: message } = await (0, prompts_1.promptAsync)({
                    type: 'text',
                    name: 'publishMessage',
                    message: `Please enter an update message.`,
                    initial: `Republish "${oldMessage}" - group: ${group}`,
                    validate: (value) => (value ? true : validationMessage),
                }));
            }
        }
        else {
            if (!message && autoFlag) {
                message = (_b = (await (0, vcs_1.getVcsClient)().getLastCommitMessageAsync())) === null || _b === void 0 ? void 0 : _b.trim();
            }
            if (!message) {
                const validationMessage = 'publish message may not be empty.';
                if (jsonFlag) {
                    throw new Error(validationMessage);
                }
                ({ publishMessage: message } = await (0, prompts_1.promptAsync)({
                    type: 'text',
                    name: 'publishMessage',
                    message: `Please enter an update message.`,
                    initial: (_c = (await (0, vcs_1.getVcsClient)().getLastCommitMessageAsync())) === null || _c === void 0 ? void 0 : _c.trim(),
                    validate: (value) => (value ? true : validationMessage),
                }));
            }
            // build bundle and upload assets for a new publish
            if (!skipBundler) {
                const bundleSpinner = (0, ora_1.ora)().start('Building bundle...');
                try {
                    await (0, publish_1.buildBundlesAsync)({ projectDir, inputDir });
                    bundleSpinner.succeed('Built bundle!');
                }
                catch (e) {
                    bundleSpinner.fail('Failed to build bundle!');
                    throw e;
                }
            }
            const assetSpinner = (0, ora_1.ora)().start('Uploading assets...');
            try {
                const platforms = platformFlag === 'all' ? exports.defaultPublishPlatforms : [platformFlag];
                const assets = await (0, publish_1.collectAssetsAsync)({ inputDir: inputDir, platforms });
                await (0, publish_1.uploadAssetsAsync)(assets);
                unsortedUpdateInfoGroups = await (0, publish_1.buildUnsortedUpdateInfoGroupAsync)(assets, exp);
                assetSpinner.succeed('Uploaded assets!');
            }
            catch (e) {
                assetSpinner.fail('Failed to upload assets');
                throw e;
            }
        }
        const runtimeToPlatformMapping = {};
        for (const runtime of new Set(Object.values(runtimeVersions))) {
            runtimeToPlatformMapping[runtime] = Object.entries(runtimeVersions)
                .filter(pair => pair[1] === runtime)
                .map(pair => pair[0]);
        }
        // Sort the updates into different groups based on their platform specific runtime versions
        const updateGroups = Object.entries(runtimeToPlatformMapping).map(([runtime, platforms]) => {
            const localUpdateInfoGroup = Object.fromEntries(platforms.map(platform => [
                platform,
                unsortedUpdateInfoGroups[platform],
            ]));
            if (republish && !oldRuntimeVersion) {
                throw new Error('Cannot find the runtime version of the update group that is being republished.');
            }
            return {
                branchId,
                updateInfoGroup: localUpdateInfoGroup,
                runtimeVersion: republish ? oldRuntimeVersion : runtime,
                message,
                awaitingCodeSigningInfo: !!codeSigningInfo,
            };
        });
        let newUpdates;
        const publishSpinner = (0, ora_1.ora)('Publishing...').start();
        try {
            newUpdates = await PublishMutation_1.PublishMutation.publishUpdateGroupAsync(updateGroups);
            if (codeSigningInfo) {
                log_1.default.log('🔒 Signing updates');
                const updatesTemp = [...newUpdates];
                const updateGroupsAndTheirUpdates = updateGroups.map(updateGroup => {
                    const newUpdates = updatesTemp.splice(0, Object.keys(updateGroup.updateInfoGroup).length);
                    return {
                        updateGroup,
                        newUpdates,
                    };
                });
                await Promise.all(updateGroupsAndTheirUpdates.map(async ({ updateGroup, newUpdates }) => {
                    await Promise.all(newUpdates.map(async (newUpdate) => {
                        const response = await (0, fetch_1.default)(newUpdate.manifestPermalink, {
                            method: 'GET',
                            headers: { accept: 'multipart/mixed' },
                        });
                        const manifestBody = (0, nullthrows_1.default)(await (0, code_signing_1.getManifestBodyAsync)(response));
                        (0, code_signing_1.checkManifestBodyAgainstUpdateInfoGroup)(manifestBody, (0, nullthrows_1.default)(updateGroup.updateInfoGroup[newUpdate.platform]));
                        const manifestSignature = (0, code_signing_1.signManifestBody)(manifestBody, codeSigningInfo);
                        await PublishMutation_1.PublishMutation.setCodeSigningInfoAsync(newUpdate.id, {
                            alg: codeSigningInfo.codeSigningMetadata.alg,
                            keyid: codeSigningInfo.codeSigningMetadata.keyid,
                            sig: manifestSignature,
                        });
                    }));
                }));
            }
            publishSpinner.succeed('Published!');
        }
        catch (e) {
            publishSpinner.fail('Failed to published updates');
            throw e;
        }
        if (jsonFlag) {
            (0, json_1.printJsonOnlyOutput)(newUpdates);
        }
        else {
            if (new Set(newUpdates.map(update => update.group)).size > 1) {
                log_1.default.addNewLineIfNone();
                log_1.default.log('👉 Since multiple runtime versions are defined, multiple update groups have been published.');
            }
            log_1.default.addNewLineIfNone();
            for (const runtime of new Set(Object.values(runtimeVersions))) {
                const platforms = newUpdates
                    .filter(update => update.runtimeVersion === runtime)
                    .map(update => update.platform);
                const newUpdate = newUpdates.find(update => update.runtimeVersion === runtime);
                if (!newUpdate) {
                    throw new Error(`Publish response is missing updates with runtime ${runtime}.`);
                }
                log_1.default.log((0, formatFields_1.default)([
                    { label: 'branch', value: branchName },
                    { label: 'runtime version', value: runtime },
                    { label: 'platform', value: platforms.join(', ') },
                    { label: 'update group ID', value: newUpdate.group },
                    { label: 'message', value: message },
                ]));
                log_1.default.addNewLineIfNone();
            }
        }
    }
}
exports.default = UpdatePublish;
UpdatePublish.description = 'publish an update group';
UpdatePublish.flags = {
    branch: core_1.Flags.string({
        description: 'Branch to publish the update group on',
        required: false,
    }),
    message: core_1.Flags.string({
        description: 'A short message describing the update',
        required: false,
    }),
    republish: core_1.Flags.boolean({
        description: 'Republish an update group',
        exclusive: ['input-dir', 'skip-bundler'],
    }),
    group: core_1.Flags.string({
        description: 'Update group to republish',
        exclusive: ['input-dir', 'skip-bundler'],
    }),
    'input-dir': core_1.Flags.string({
        description: 'Location of the bundle',
        default: 'dist',
        required: false,
    }),
    'skip-bundler': core_1.Flags.boolean({
        description: `Skip running Expo CLI to bundle the app before publishing`,
        default: false,
    }),
    platform: core_1.Flags.enum({
        char: 'p',
        options: [...exports.defaultPublishPlatforms, 'all'],
        default: 'all',
        required: false,
    }),
    json: core_1.Flags.boolean({
        description: 'Enable JSON output, non-JSON messages will be printed to stderr',
        default: false,
    }),
    auto: core_1.Flags.boolean({
        description: 'Use the current git branch and commit message for the EAS branch and update message',
        default: false,
    }),
    'private-key-path': core_1.Flags.string({
        description: `File containing the PEM-encoded private key corresponding to the certificate in expo-updates' configuration. Defaults to a file named "private-key.pem" in the certificate's directory.`,
        required: false,
    }),
};
async function getRuntimeVersionObjectAsync(exp, platformFlag, projectDir) {
    var _a, _b;
    const platforms = (platformFlag === 'all' ? ['android', 'ios'] : [platformFlag]);
    for (const platform of platforms) {
        const isPolicy = typeof ((_b = (_a = exp[platform]) === null || _a === void 0 ? void 0 : _a.runtimeVersion) !== null && _b !== void 0 ? _b : exp.runtimeVersion) === 'object';
        if (isPolicy) {
            const isManaged = (await (0, workflow_1.resolveWorkflowAsync)(projectDir, platform)) === eas_build_job_1.Workflow.MANAGED;
            if (!isManaged) {
                throw new Error('Runtime version policies are only supported in the managed workflow. In the bare workflow, runtime version needs to be set manually.');
            }
        }
    }
    return Object.fromEntries(platforms.map(platform => [
        platform,
        (0, nullthrows_1.default)(config_plugins_1.Updates.getRuntimeVersion(exp, platform), `Unable to determine runtime version for ${platform}`),
    ]));
}
function formatUpdateTitle(update) {
    const { message, createdAt, actor, runtimeVersion } = update;
    let actorName;
    switch (actor === null || actor === void 0 ? void 0 : actor.__typename) {
        case 'User': {
            actorName = actor.username;
            break;
        }
        case 'Robot': {
            const { firstName, id } = actor;
            actorName = firstName !== null && firstName !== void 0 ? firstName : `robot: ${id.slice(0, 4)}...`;
            break;
        }
        default:
            actorName = 'unknown';
    }
    return `[${(0, dateformat_1.default)(createdAt, 'mmm dd HH:MM')} by ${actorName}, runtimeVersion: ${runtimeVersion}] ${message}`;
}
async function checkEASUpdateURLIsSetAsync(exp) {
    var _a;
    const configuredURL = (_a = exp.updates) === null || _a === void 0 ? void 0 : _a.url;
    const projectId = await (0, projectUtils_1.getProjectIdAsync)(exp);
    const expectedURL = (0, api_1.getEASUpdateURL)(projectId);
    if (configuredURL !== expectedURL) {
        throw new Error(`The update URL is incorrectly configured for EAS Update. Please set updates.url to ${expectedURL} in your app.json.`);
    }
}
