"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const config_1 = require("@expo/config");
const eas_build_job_1 = require("@expo/eas-build-job");
const core_1 = require("@oclif/core");
const assert_1 = tslib_1.__importDefault(require("assert"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const api_1 = require("../../api");
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const generated_1 = require("../../graphql/generated");
const log_1 = tslib_1.__importStar(require("../../log"));
const platform_1 = require("../../platform");
const projectUtils_1 = require("../../project/projectUtils");
const workflow_1 = require("../../project/workflow");
const UpdatesModule_1 = require("../../update/android/UpdatesModule");
const UpdatesModule_2 = require("../../update/ios/UpdatesModule");
const DEFAULT_MANAGED_RUNTIME_VERSION = { policy: 'sdkVersion' };
const DEFAULT_BARE_RUNTIME_VERSION = '1.0.0';
class UpdateConfigure extends EasCommand_1.default {
    async runAsync() {
        log_1.default.log('ðŸ’¡ The following process will configure your project to run EAS Update. These changes only apply to your local project files and you can safely revert them at any time.');
        const { flags } = await this.parse(UpdateConfigure);
        const platform = flags.platform;
        const projectDir = await (0, projectUtils_1.findProjectRootAsync)();
        const { exp } = (0, config_1.getConfig)(projectDir, {
            skipSDKVersionRequirement: true,
        });
        if (!(0, projectUtils_1.isExpoUpdatesInstalledOrAvailable)(projectDir, exp.sdkVersion)) {
            await (0, projectUtils_1.installExpoUpdatesAsync)(projectDir);
        }
        const [androidWorkflow, iosWorkflow] = await Promise.all([
            (0, workflow_1.resolveWorkflowAsync)(projectDir, eas_build_job_1.Platform.ANDROID),
            (0, workflow_1.resolveWorkflowAsync)(projectDir, eas_build_job_1.Platform.IOS),
        ]);
        const updatedExp = await configureAppJSONForEASUpdateAsync({
            projectDir,
            exp,
            platform,
            workflows: {
                android: androidWorkflow,
                ios: iosWorkflow,
            },
        });
        log_1.default.withTick(`Configured ${chalk_1.default.bold('app.json')} for EAS Update`);
        // configure native files for EAS Update
        if ([platform_1.RequestedPlatform.Android, platform_1.RequestedPlatform.All].includes(platform) &&
            androidWorkflow === eas_build_job_1.Workflow.GENERIC) {
            await (0, UpdatesModule_1.syncUpdatesConfigurationAsync)(projectDir, updatedExp);
            log_1.default.withTick(`Configured ${chalk_1.default.bold('AndroidManifest.xml')} for EAS Update`);
        }
        if ([platform_1.RequestedPlatform.Ios, platform_1.RequestedPlatform.All].includes(platform) &&
            iosWorkflow === eas_build_job_1.Workflow.GENERIC) {
            await (0, UpdatesModule_2.syncUpdatesConfigurationAsync)(projectDir, updatedExp);
            log_1.default.withTick(`Configured ${chalk_1.default.bold('Expo.plist')} for EAS Update`);
        }
        log_1.default.addNewLineIfNone();
        log_1.default.log(`ðŸŽ‰ Your app is configured to run EAS Update!`);
    }
}
exports.default = UpdateConfigure;
UpdateConfigure.description = 'configure the project to support EAS Update';
UpdateConfigure.flags = {
    platform: core_1.Flags.enum({
        description: 'Platform to configure',
        char: 'p',
        options: ['android', 'ios', 'all'],
        default: 'all',
    }),
};
async function configureAppJSONForEASUpdateAsync({ projectDir, exp, platform, workflows, }) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
    const projectId = await (0, projectUtils_1.getProjectIdAsync)(exp);
    const easUpdateURL = (0, api_1.getEASUpdateURL)(projectId);
    const updates = { ...exp.updates, url: easUpdateURL };
    const androidDefaultRuntimeVersion = workflows['android'] === eas_build_job_1.Workflow.GENERIC
        ? DEFAULT_BARE_RUNTIME_VERSION
        : DEFAULT_MANAGED_RUNTIME_VERSION;
    const iosDefaultRuntimeVersion = workflows['ios'] === eas_build_job_1.Workflow.GENERIC
        ? DEFAULT_BARE_RUNTIME_VERSION
        : DEFAULT_MANAGED_RUNTIME_VERSION;
    const newAndroidRuntimeVersion = (_c = (_b = (_a = exp.android) === null || _a === void 0 ? void 0 : _a.runtimeVersion) !== null && _b !== void 0 ? _b : exp.runtimeVersion) !== null && _c !== void 0 ? _c : androidDefaultRuntimeVersion;
    const newIosRuntimeVersion = (_f = (_e = (_d = exp.ios) === null || _d === void 0 ? void 0 : _d.runtimeVersion) !== null && _e !== void 0 ? _e : exp.runtimeVersion) !== null && _f !== void 0 ? _f : iosDefaultRuntimeVersion;
    let newConfig;
    switch (platform) {
        case platform_1.RequestedPlatform.All: {
            if (isRuntimeEqual(newAndroidRuntimeVersion, newIosRuntimeVersion)) {
                newConfig = {
                    runtimeVersion: newAndroidRuntimeVersion,
                    android: {
                        ...exp.android,
                        runtimeVersion: undefined,
                    },
                    ios: { ...exp.ios, runtimeVersion: undefined },
                    updates,
                };
            }
            else {
                newConfig = {
                    runtimeVersion: undefined,
                    android: {
                        ...exp.android,
                        runtimeVersion: newAndroidRuntimeVersion,
                    },
                    ios: {
                        ...exp.ios,
                        runtimeVersion: newIosRuntimeVersion,
                    },
                    updates,
                };
            }
            break;
        }
        case platform_1.RequestedPlatform.Android: {
            newConfig = {
                android: {
                    ...exp.android,
                    runtimeVersion: newAndroidRuntimeVersion,
                },
                updates,
            };
            break;
        }
        case platform_1.RequestedPlatform.Ios: {
            newConfig = {
                ios: {
                    ...exp.ios,
                    runtimeVersion: newIosRuntimeVersion,
                },
                updates,
            };
            break;
        }
        default: {
            throw new Error(`Unsupported platform: ${platform}`);
        }
    }
    const result = await (0, config_1.modifyConfigAsync)(projectDir, newConfig);
    const prexistingAndroidRuntimeVersion = (_h = (_g = exp.android) === null || _g === void 0 ? void 0 : _g.runtimeVersion) !== null && _h !== void 0 ? _h : exp.runtimeVersion;
    const prexistingIosRuntimeVersion = (_k = (_j = exp.ios) === null || _j === void 0 ? void 0 : _j.runtimeVersion) !== null && _k !== void 0 ? _k : exp.runtimeVersion;
    switch (result.type) {
        case 'success':
            if ((_l = exp.updates) === null || _l === void 0 ? void 0 : _l.url) {
                if (exp.updates.url !== easUpdateURL) {
                    log_1.default.withTick(`Overwrote "${(_m = exp.updates) === null || _m === void 0 ? void 0 : _m.url}" with "${easUpdateURL}" for the updates.url value in app.json`);
                }
            }
            else {
                log_1.default.withTick(`Set updates.url value, to "${easUpdateURL}" in app.json`);
            }
            if (!prexistingAndroidRuntimeVersion &&
                [platform_1.RequestedPlatform.Android, platform_1.RequestedPlatform.All].includes(platform)) {
                log_1.default.withTick(`Set ${platform_1.appPlatformDisplayNames[generated_1.AppPlatform.Android]} runtimeVersion to "${JSON.stringify((_p = (_o = newConfig.android) === null || _o === void 0 ? void 0 : _o.runtimeVersion) !== null && _p !== void 0 ? _p : newConfig.runtimeVersion)}" in app.json`);
            }
            if (!prexistingIosRuntimeVersion &&
                [platform_1.RequestedPlatform.Ios, platform_1.RequestedPlatform.All].includes(platform)) {
                log_1.default.withTick(`Set ${platform_1.appPlatformDisplayNames[generated_1.AppPlatform.Ios]} runtimeVersion to "${JSON.stringify((_r = (_q = newConfig.ios) === null || _q === void 0 ? void 0 : _q.runtimeVersion) !== null && _r !== void 0 ? _r : newConfig.runtimeVersion)}" in app.json`);
            }
            break;
        case 'warn': {
            log_1.default.addNewLineIfNone();
            log_1.default.warn(`It looks like you are using a dynamic configuration! ${(0, log_1.learnMore)('https://docs.expo.dev/workflow/configuration/#dynamic-configuration-with-appconfigjs)')}`);
            log_1.default.warn(`In order to finish configuring your project for EAS Update, you are going to need manually add the following to your app.config.js:\n${(0, log_1.learnMore)('https://expo.fyi/eas-update-config.md')}\n`);
            log_1.default.log(chalk_1.default.bold(JSON.stringify(newConfig, null, 2)));
            log_1.default.addNewLineIfNone();
            if (workflows['android'] === eas_build_job_1.Workflow.GENERIC || workflows['ios'] === eas_build_job_1.Workflow.GENERIC) {
                log_1.default.warn(`You will also have to manually edit the projects ${chalk_1.default.bold('Expo.plist/AndroidManifest.xml')}. ${(0, log_1.learnMore)('https://expo.fyi/eas-update-config.md#native-configuration')}`);
            }
            log_1.default.addNewLineIfNone();
            throw new Error(result.message);
        }
        case 'fail':
            throw new Error(result.message);
        default:
            throw new Error('Unexpected result type from modifyConfigAsync');
    }
    (0, assert_1.default)(result.config, 'A successful result should have a config');
    return result.config.expo;
}
function isRuntimeEqual(runtimeVersionA, runtimeVersionB) {
    if (typeof runtimeVersionA === 'string' && typeof runtimeVersionB === 'string') {
        return runtimeVersionA === runtimeVersionB;
    }
    else if (typeof runtimeVersionA === 'object' && typeof runtimeVersionB === 'object') {
        return runtimeVersionA.policy === runtimeVersionB.policy;
    }
    else {
        return false;
    }
}
