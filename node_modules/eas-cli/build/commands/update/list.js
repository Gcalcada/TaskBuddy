"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const config_1 = require("@expo/config");
const core_1 = require("@oclif/core");
const assert_1 = tslib_1.__importDefault(require("assert"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const cli_table3_1 = tslib_1.__importDefault(require("cli-table3"));
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const UpdateQuery_1 = require("../../graphql/queries/UpdateQuery");
const log_1 = tslib_1.__importDefault(require("../../log"));
const projectUtils_1 = require("../../project/projectUtils");
const prompts_1 = require("../../prompts");
const utils_1 = require("../../update/utils");
const groupBy_1 = tslib_1.__importDefault(require("../../utils/expodash/groupBy"));
const json_1 = require("../../utils/json");
const vcs_1 = require("../../vcs");
class BranchView extends EasCommand_1.default {
    async runAsync() {
        var _a, _b;
        const { flags: { branch: branchFlag, all, json: jsonFlag }, } = await this.parse(BranchView);
        if (jsonFlag) {
            (0, json_1.enableJsonOutput)();
        }
        const projectDir = await (0, projectUtils_1.findProjectRootAsync)();
        const { exp } = (0, config_1.getConfig)(projectDir, { skipSDKVersionRequirement: true });
        const projectId = await (0, projectUtils_1.getProjectIdAsync)(exp);
        let updateGroupDescriptions;
        if (all) {
            const branchesAndUpdates = await UpdateQuery_1.UpdateQuery.viewAllAsync({ appId: projectId });
            updateGroupDescriptions = getUpdateGroupDescriptions(branchesAndUpdates.app.byId.updateBranches);
        }
        else {
            let branchInteractive;
            if (!branchFlag) {
                const validationMessage = 'Branch name may not be empty.';
                if (jsonFlag) {
                    throw new Error(validationMessage);
                }
                ({ name: branchInteractive } = await (0, prompts_1.promptAsync)({
                    type: 'text',
                    name: 'name',
                    message: 'Please enter the name of the branch whose updates you wish to view:',
                    initial: (_a = (await (0, vcs_1.getVcsClient)().getBranchNameAsync())) !== null && _a !== void 0 ? _a : undefined,
                    validate: (value) => (value ? true : validationMessage),
                }));
            }
            const branch = branchFlag !== null && branchFlag !== void 0 ? branchFlag : branchInteractive;
            (0, assert_1.default)(branch, 'Branch name may not be empty.');
            const branchesAndUpdates = await UpdateQuery_1.UpdateQuery.viewBranchAsync({
                appId: projectId,
                name: branch,
            });
            const UpdateBranch = (_b = branchesAndUpdates.app) === null || _b === void 0 ? void 0 : _b.byId.updateBranchByName;
            if (!UpdateBranch) {
                throw new Error(`Could not find branch "${branch}"`);
            }
            updateGroupDescriptions = getUpdateGroupDescriptions([UpdateBranch]);
        }
        if (jsonFlag) {
            (0, json_1.printJsonOnlyOutput)(updateGroupDescriptions);
        }
        else {
            logAsTable(updateGroupDescriptions);
        }
    }
}
exports.default = BranchView;
BranchView.description = 'view the recent updates for a branch';
BranchView.flags = {
    branch: core_1.Flags.string({
        description: 'List all updates on this branch',
        exclusive: ['all'],
    }),
    all: core_1.Flags.boolean({
        description: 'List all updates associated with this project',
        exclusive: ['branch'],
        default: false,
    }),
    json: core_1.Flags.boolean({
        description: `Return a json with all of the recent update groups.`,
        default: false,
    }),
};
function getUpdateGroupDescriptions(branchesAndUpdates) {
    const flattenedBranchesAndUpdates = branchesAndUpdates.flatMap(branch => branch.updates.map(update => {
        return { branch: branch.name, ...update };
    }));
    const updateGroupDescriptions = Object.values((0, groupBy_1.default)(flattenedBranchesAndUpdates, update => update.group)).map(updateGroup => {
        const platforms = updateGroup
            .map(update => update.platform)
            .sort()
            .join(', ');
        return { ...updateGroup[0], platforms };
    });
    updateGroupDescriptions.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());
    return updateGroupDescriptions;
}
function logAsTable(updateGroupDescriptions) {
    const table = new cli_table3_1.default({
        head: ['Branch', ...utils_1.UPDATE_COLUMNS],
        wordWrap: true,
    });
    table.push(...updateGroupDescriptions.map(updateGroupDescription => [
        updateGroupDescription.branch,
        (0, utils_1.formatUpdate)(updateGroupDescription),
        updateGroupDescription.runtimeVersion,
        updateGroupDescription.group,
        updateGroupDescription.platforms,
    ]));
    log_1.default.addNewLineIfNone();
    log_1.default.log(chalk_1.default.bold('Recently published update groups:'));
    log_1.default.log(table.toString());
}
