"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.logChannelDetails = exports.getBranchMapping = void 0;
const tslib_1 = require("tslib");
const config_1 = require("@expo/config");
const core_1 = require("@oclif/core");
const assert_1 = tslib_1.__importDefault(require("assert"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const cli_table3_1 = tslib_1.__importDefault(require("cli-table3"));
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const ChannelQuery_1 = require("../../graphql/queries/ChannelQuery");
const log_1 = tslib_1.__importDefault(require("../../log"));
const projectUtils_1 = require("../../project/projectUtils");
const prompts_1 = require("../../prompts");
const utils_1 = require("../../update/utils");
const formatFields_1 = tslib_1.__importDefault(require("../../utils/formatFields"));
const json_1 = require("../../utils/json");
/**
 * Get the branch mapping and determine whether it is a rollout.
 * Ensure that the branch mapping is properly formatted.
 */
function getBranchMapping(branchMappingString) {
    if (!branchMappingString) {
        throw new Error('Missing branch mapping.');
    }
    let branchMapping;
    try {
        branchMapping = JSON.parse(branchMappingString);
    }
    catch (e) {
        throw new Error(`Could not parse branchMapping string into a JSON: "${branchMappingString}"`);
    }
    (0, assert_1.default)(branchMapping, 'Branch Mapping must be defined.');
    if (branchMapping.version !== 0) {
        throw new Error('Branch mapping must be version 0.');
    }
    const isRollout = branchMapping.data.length === 2;
    const rolloutPercent = branchMapping.data[0].branchMappingLogic.operand;
    switch (branchMapping.data.length) {
        case 0:
            break;
        case 1:
            if (branchMapping.data[0].branchMappingLogic !== 'true') {
                throw new Error('Branch mapping logic for a single branch must be "true"');
            }
            break;
        case 2:
            if (branchMapping.data[0].branchMappingLogic.clientKey !== 'rolloutToken') {
                throw new Error('Client key of initial branch mapping must be "rolloutToken"');
            }
            if (branchMapping.data[0].branchMappingLogic.branchMappingOperator !== 'hash_lt') {
                throw new Error('Branch mapping operator of initial branch mapping must be "hash_lt"');
            }
            if (rolloutPercent == null) {
                throw new Error('Branch mapping is missing a "rolloutPercent"');
            }
            if (branchMapping.data[1].branchMappingLogic !== 'true') {
                throw new Error('Branch mapping logic for a the second branch of a rollout must be "true"');
            }
            break;
        default:
            throw new Error('Branch mapping data must have length less than or equal to 2.');
    }
    return { branchMapping, isRollout, rolloutPercent };
}
exports.getBranchMapping = getBranchMapping;
function logChannelDetails(channel) {
    var _a, _b, _c;
    const { branchMapping, isRollout, rolloutPercent } = getBranchMapping(channel.branchMapping);
    const table = new cli_table3_1.default({
        head: ['branch', ...(isRollout ? ['rollout percent'] : []), ...utils_1.UPDATE_COLUMNS],
        wordWrap: true,
    });
    for (const index in branchMapping.data) {
        if (parseInt(index, 10) > 1) {
            throw new Error('Branch Mapping data must have length less than or equal to 2.');
        }
        const { branchId } = branchMapping.data[index];
        const branch = channel.updateBranches.filter(branch => branch.id === branchId)[0];
        if (!branch) {
            throw new Error('Branch mapping is pointing at a missing branch.');
        }
        const update = branch.updates[0];
        table.push([
            branch.name,
            ...(isRollout
                ? [
                    parseInt(index, 10) === 0
                        ? `${rolloutPercent * 100}%`
                        : `${(1 - rolloutPercent) * 100}%`,
                ]
                : []),
            (0, utils_1.formatUpdate)(update),
            (_a = update === null || update === void 0 ? void 0 : update.runtimeVersion) !== null && _a !== void 0 ? _a : 'N/A',
            (_b = update === null || update === void 0 ? void 0 : update.group) !== null && _b !== void 0 ? _b : 'N/A',
            (0, utils_1.getPlatformsForGroup)({
                updates: branch.updates,
                group: (_c = branch.updates[0]) === null || _c === void 0 ? void 0 : _c.group,
            }),
        ]);
    }
    log_1.default.log(table.toString());
}
exports.logChannelDetails = logChannelDetails;
class ChannelView extends EasCommand_1.default {
    async runAsync() {
        let { args: { name: channelName }, flags: { json: jsonFlag }, } = await this.parse(ChannelView);
        if (jsonFlag) {
            (0, json_1.enableJsonOutput)();
        }
        const projectDir = await (0, projectUtils_1.findProjectRootAsync)();
        const { exp } = (0, config_1.getConfig)(projectDir, { skipSDKVersionRequirement: true });
        const projectId = await (0, projectUtils_1.getProjectIdAsync)(exp);
        if (!channelName) {
            const validationMessage = 'A channel name is required to view a specific channel.';
            if (jsonFlag) {
                throw new Error(validationMessage);
            }
            ({ name: channelName } = await (0, prompts_1.promptAsync)({
                type: 'text',
                name: 'name',
                message: 'Please name the channel:',
                validate: value => (value ? true : validationMessage),
            }));
        }
        const channel = await ChannelQuery_1.ChannelQuery.getUpdateChannelByNameForAppAsync({
            appId: projectId,
            channelName,
        });
        if (!channel) {
            throw new Error(`Could not find a channel with name: ${channelName}`);
        }
        if (jsonFlag) {
            (0, json_1.printJsonOnlyOutput)(channel);
        }
        else {
            log_1.default.addNewLineIfNone();
            log_1.default.log(chalk_1.default.bold('Channel:'));
            log_1.default.log((0, formatFields_1.default)([
                { label: 'Name', value: channel.name },
                { label: 'ID', value: channel.id },
            ]));
            log_1.default.addNewLineIfNone();
            log_1.default.log((0, chalk_1.default) `{bold Branches pointed at this channel and their most recent update group:}`);
            logChannelDetails(channel);
        }
    }
}
exports.default = ChannelView;
ChannelView.description = 'view a channel';
ChannelView.args = [
    {
        name: 'name',
        required: false,
        description: 'Name of the channel to view',
    },
];
ChannelView.flags = {
    json: core_1.Flags.boolean({
        description: 'print output as a JSON object with the channel ID, name and branch mapping.',
        default: false,
    }),
};
