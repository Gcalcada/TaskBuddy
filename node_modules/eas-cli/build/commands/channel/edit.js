"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateChannelBranchMappingAsync = void 0;
const tslib_1 = require("tslib");
const config_1 = require("@expo/config");
const core_1 = require("@oclif/core");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const graphql_tag_1 = tslib_1.__importDefault(require("graphql-tag"));
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const client_1 = require("../../graphql/client");
const BranchQuery_1 = require("../../graphql/queries/BranchQuery");
const log_1 = tslib_1.__importDefault(require("../../log"));
const projectUtils_1 = require("../../project/projectUtils");
const prompts_1 = require("../../prompts");
const json_1 = require("../../utils/json");
async function getChannelByNameForAppAsync({ appId, channelName, }) {
    var _a;
    const data = await (0, client_1.withErrorHandlingAsync)(client_1.graphqlClient
        .query((0, graphql_tag_1.default) `
          query GetChannelByNameToEdit($appId: String!, $channelName: String!) {
            app {
              byId(appId: $appId) {
                id
                updateChannelByName(name: $channelName) {
                  id
                  name
                  updateBranches(offset: 0, limit: 1) {
                    id
                    name
                  }
                }
              }
            }
          }
        `, { appId, channelName }, { additionalTypenames: ['UpdateChannel', 'UpdateBranch'] })
        .toPromise());
    const updateChannelByNameResult = (_a = data.app) === null || _a === void 0 ? void 0 : _a.byId.updateChannelByName;
    if (!updateChannelByNameResult) {
        throw new Error(`Could not find a channel named ${channelName} on app with id ${appId}`);
    }
    return updateChannelByNameResult;
}
async function updateChannelBranchMappingAsync({ channelId, branchMapping, }) {
    const data = await (0, client_1.withErrorHandlingAsync)(client_1.graphqlClient
        .mutation((0, graphql_tag_1.default) `
          mutation UpdateChannelBranchMapping($channelId: ID!, $branchMapping: String!) {
            updateChannel {
              editUpdateChannel(channelId: $channelId, branchMapping: $branchMapping) {
                id
                name
                branchMapping
              }
            }
          }
        `, { channelId, branchMapping })
        .toPromise());
    const channel = data.updateChannel.editUpdateChannel;
    if (!channel) {
        throw new Error(`Could not find a channel with id: ${channelId}`);
    }
    return data.updateChannel.editUpdateChannel;
}
exports.updateChannelBranchMappingAsync = updateChannelBranchMappingAsync;
class ChannelEdit extends EasCommand_1.default {
    async runAsync() {
        var _a, _b;
        const { args, flags } = await this.parse(ChannelEdit);
        if (flags.json) {
            (0, json_1.enableJsonOutput)();
        }
        const projectDir = await (0, projectUtils_1.findProjectRootAsync)();
        const { exp } = (0, config_1.getConfig)(projectDir, { skipSDKVersionRequirement: true });
        const projectId = await (0, projectUtils_1.getProjectIdAsync)(exp);
        const channelName = (_a = args.name) !== null && _a !== void 0 ? _a : (await promptForChannelAsync());
        const existingChannel = await getChannelByNameForAppAsync({ appId: projectId, channelName });
        if (existingChannel.updateBranches.length > 1) {
            throw new Error('There is a rollout in progress. Please manage it with "channel:rollout" instead.');
        }
        const branchName = (_b = flags.branch) !== null && _b !== void 0 ? _b : (await promptForBranchAsync());
        const branch = await BranchQuery_1.BranchQuery.getBranchByNameAsync({
            appId: projectId,
            name: branchName,
        });
        if (!branch) {
            throw new Error(`Could not find a branch named "${branchName}". Please check what branches exist on this project with ${chalk_1.default.bold('eas branch:list')}.`);
        }
        const channel = await updateChannelBranchMappingAsync({
            channelId: existingChannel.id,
            // todo: move branch mapping logic to utility
            branchMapping: JSON.stringify({
                data: [{ branchId: branch.id, branchMappingLogic: 'true' }],
                version: 0,
            }),
        });
        if (flags.json) {
            (0, json_1.printJsonOnlyOutput)(channel);
        }
        else {
            log_1.default.withTick((0, chalk_1.default) `Channel {bold ${channel.name}} is now set to branch {bold ${branch.name}}.\n`);
            log_1.default.addNewLineIfNone();
            log_1.default.log((0, chalk_1.default) `Users with builds on channel {bold ${channel.name}} will now receive the active update on {bold ${branch.name}}.`);
        }
    }
}
exports.default = ChannelEdit;
ChannelEdit.description = 'point a channel at a new branch';
ChannelEdit.args = [
    {
        name: 'name',
        required: false,
        description: 'Name of the channel to edit',
    },
];
ChannelEdit.flags = {
    branch: core_1.Flags.string({
        description: 'Name of the branch to point to',
    }),
    json: core_1.Flags.boolean({
        description: 'Print output as a JSON object with the channel ID, name and branch mapping',
        default: false,
    }),
};
async function promptForChannelAsync() {
    log_1.default.addNewLineIfNone();
    const { name } = await (0, prompts_1.promptAsync)({
        type: 'text',
        name: 'name',
        message: 'Please enter the name of the channel to edit:',
        validate: value => (value ? true : 'The channel name may not be empty.'),
    });
    return name;
}
async function promptForBranchAsync() {
    log_1.default.addNewLineIfNone();
    const { name } = await (0, prompts_1.promptAsync)({
        type: 'text',
        name: 'name',
        message: `To which branch should the channel link?`,
        validate: value => (value ? true : 'The branch name may not be empty.'),
    });
    return name;
}
