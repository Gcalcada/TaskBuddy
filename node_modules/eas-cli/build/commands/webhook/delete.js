"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const config_1 = require("@expo/config");
const assert_1 = tslib_1.__importDefault(require("assert"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const nullthrows_1 = tslib_1.__importDefault(require("nullthrows"));
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const WebhookMutation_1 = require("../../graphql/mutations/WebhookMutation");
const WebhookQuery_1 = require("../../graphql/queries/WebhookQuery");
const log_1 = tslib_1.__importDefault(require("../../log"));
const ora_1 = require("../../ora");
const projectUtils_1 = require("../../project/projectUtils");
const prompts_1 = require("../../prompts");
const formatWebhook_1 = require("../../webhooks/formatWebhook");
class WebhookDelete extends EasCommand_1.default {
    async runAsync() {
        let { args: { ID: webhookId }, } = await this.parse(WebhookDelete);
        const projectDir = await (0, projectUtils_1.findProjectRootAsync)();
        const { exp } = (0, config_1.getConfig)(projectDir, { skipSDKVersionRequirement: true });
        const projectId = await (0, projectUtils_1.getProjectIdAsync)(exp);
        let webhook = webhookId && (await WebhookQuery_1.WebhookQuery.byIdAsync(webhookId));
        if (!webhookId) {
            const webhooks = await fetchWebhooksByAppIdAsync(projectId);
            if (webhooks.length === 0) {
                process.exit(1);
            }
            ({ webhook } = await (0, prompts_1.promptAsync)({
                type: 'autocomplete',
                name: 'webhook',
                message: 'Pick the webhook to be deleted:',
                choices: webhooks.map(i => ({
                    title: `${chalk_1.default.bold(i.url)} (Event: ${i.event}, ID: ${i.id})`,
                    value: i,
                })),
            }));
            webhookId = (0, nullthrows_1.default)(webhook).id;
        }
        (0, assert_1.default)(webhook, 'Webhook must be defined here');
        log_1.default.addNewLineIfNone();
        log_1.default.log((0, formatWebhook_1.formatWebhook)(webhook));
        log_1.default.newLine();
        log_1.default.warn(`You are about to permamently delete this webhook.\nThis action is irreversible.`);
        log_1.default.newLine();
        const confirmed = await (0, prompts_1.toggleConfirmAsync)({
            message: 'Are you sure you wish to proceed?',
        });
        if (!confirmed) {
            log_1.default.error(`Canceled deletion of the webhook`);
            process.exit(1);
        }
        const spinner = (0, ora_1.ora)('Deleting the webhook').start();
        try {
            await WebhookMutation_1.WebhookMutation.deleteWebhookAsync(webhookId);
            spinner.succeed('Successfully deleted the webhook');
        }
        catch (err) {
            spinner.fail('Failed to delete the webhook');
            throw err;
        }
    }
}
exports.default = WebhookDelete;
WebhookDelete.description = 'delete a webhook';
WebhookDelete.args = [
    {
        name: 'ID',
        required: false,
        description: 'ID of the webhook to delete',
    },
];
async function fetchWebhooksByAppIdAsync(appId) {
    const spinner = (0, ora_1.ora)('Fetching webhooks').start();
    try {
        const webhooks = await WebhookQuery_1.WebhookQuery.byAppIdAsync(appId);
        if (webhooks.length === 0) {
            spinner.fail('There are no webhooks on the project');
            return [];
        }
        else {
            spinner.succeed(`Successfully fetched ${webhooks.length} webhooks`);
            return webhooks;
        }
    }
    catch (err) {
        spinner.fail("Something went wrong and we couldn't fetch the webhook list");
        throw err;
    }
}
