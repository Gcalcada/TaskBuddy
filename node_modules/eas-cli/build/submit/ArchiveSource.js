"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isUuidV4 = exports.getArchiveAsync = exports.ArchiveSourceType = exports.BUILD_LIST_ITEM_COUNT = void 0;
const tslib_1 = require("tslib");
const eas_build_job_1 = require("@expo/eas-build-job");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const url_1 = require("url");
const uuid = tslib_1.__importStar(require("uuid"));
const generated_1 = require("../graphql/generated");
const BuildQuery_1 = require("../graphql/queries/BuildQuery");
const AppPlatform_1 = require("../graphql/types/AppPlatform");
const log_1 = tslib_1.__importStar(require("../log"));
const platform_1 = require("../platform");
const prompts_1 = require("../prompts");
const builds_1 = require("./utils/builds");
const files_1 = require("./utils/files");
exports.BUILD_LIST_ITEM_COUNT = 4;
var ArchiveSourceType;
(function (ArchiveSourceType) {
    ArchiveSourceType[ArchiveSourceType["url"] = 0] = "url";
    ArchiveSourceType[ArchiveSourceType["latest"] = 1] = "latest";
    ArchiveSourceType[ArchiveSourceType["path"] = 2] = "path";
    ArchiveSourceType[ArchiveSourceType["buildId"] = 3] = "buildId";
    ArchiveSourceType[ArchiveSourceType["buildList"] = 4] = "buildList";
    ArchiveSourceType[ArchiveSourceType["prompt"] = 5] = "prompt";
})(ArchiveSourceType = exports.ArchiveSourceType || (exports.ArchiveSourceType = {}));
async function getArchiveAsync(source) {
    switch (source.sourceType) {
        case ArchiveSourceType.prompt: {
            return await handlePromptSourceAsync(source);
        }
        case ArchiveSourceType.url: {
            return await handleUrlSourceAsync(source);
        }
        case ArchiveSourceType.latest: {
            return await handleLatestSourceAsync(source);
        }
        case ArchiveSourceType.path: {
            return await handlePathSourceAsync(source);
        }
        case ArchiveSourceType.buildId: {
            return await handleBuildIdSourceAsync(source);
        }
        case ArchiveSourceType.buildList: {
            return await handleBuildListSourceAsync(source);
        }
    }
}
exports.getArchiveAsync = getArchiveAsync;
async function handleUrlSourceAsync(source) {
    const { url } = source;
    if (!validateUrl(url)) {
        log_1.default.error(chalk_1.default.bold(`The URL you provided is invalid: ${url}`));
        return getArchiveAsync({
            ...source,
            sourceType: ArchiveSourceType.prompt,
        });
    }
    const maybeBuildId = isBuildDetailsPage(url);
    if (maybeBuildId) {
        if (await askIfUseBuildIdFromUrlAsync(source, maybeBuildId)) {
            return getArchiveAsync({
                ...source,
                sourceType: ArchiveSourceType.buildId,
                id: maybeBuildId,
            });
        }
    }
    return {
        url,
        source,
    };
}
async function handleLatestSourceAsync(source) {
    try {
        const [latestBuild] = await (0, builds_1.getRecentBuildsForSubmissionAsync)((0, AppPlatform_1.toAppPlatform)(source.platform), source.projectId);
        if (!latestBuild) {
            log_1.default.error(chalk_1.default.bold("Couldn't find any builds for this project on EAS servers. It looks like you haven't run 'eas build' yet."));
            return getArchiveAsync({
                ...source,
                sourceType: ArchiveSourceType.prompt,
            });
        }
        return {
            build: latestBuild,
            source,
        };
    }
    catch (err) {
        log_1.default.error(err);
        throw err;
    }
}
async function handlePathSourceAsync(source) {
    if (!(await (0, files_1.isExistingFileAsync)(source.path))) {
        log_1.default.error(chalk_1.default.bold(`${source.path} doesn't exist`));
        return getArchiveAsync({
            ...source,
            sourceType: ArchiveSourceType.prompt,
        });
    }
    log_1.default.log('Uploading your app archive to the Expo Submission Service');
    const uploadUrl = await (0, files_1.uploadAppArchiveAsync)(source.path);
    return {
        url: uploadUrl,
        source,
    };
}
async function handleBuildIdSourceAsync(source) {
    try {
        const build = await BuildQuery_1.BuildQuery.byIdAsync(source.id);
        if (build.platform !== (0, AppPlatform_1.toAppPlatform)(source.platform)) {
            const expectedPlatformName = platform_1.appPlatformDisplayNames[(0, AppPlatform_1.toAppPlatform)(source.platform)];
            const receivedPlatformName = platform_1.appPlatformDisplayNames[build.platform];
            log_1.default.error(chalk_1.default.bold(`Build platform doesn't match! Expected ${expectedPlatformName} build but got ${receivedPlatformName}.`));
            return getArchiveAsync({
                ...source,
                sourceType: ArchiveSourceType.prompt,
            });
        }
        return {
            build,
            source,
        };
    }
    catch (err) {
        log_1.default.error(chalk_1.default.bold(`Could not find build with ID ${source.id}`));
        log_1.default.warn('Are you sure that the given ID corresponds to a build from EAS Build?');
        log_1.default.warn(`Build IDs from the classic build service (expo build:[android|ios]) are not supported. ${(0, log_1.learnMore)('https://docs.expo.dev/submit/classic-builds/')}`);
        log_1.default.debug('Original error:', err);
        return getArchiveAsync({
            ...source,
            sourceType: ArchiveSourceType.prompt,
        });
    }
}
async function handleBuildListSourceAsync(source) {
    try {
        const appPlatform = (0, AppPlatform_1.toAppPlatform)(source.platform);
        const expiryDate = new Date(); // artifacts expire after 30 days
        expiryDate.setDate(expiryDate.getDate() - 30);
        const recentBuilds = await (0, builds_1.getRecentBuildsForSubmissionAsync)(appPlatform, source.projectId, {
            limit: exports.BUILD_LIST_ITEM_COUNT,
        });
        if (recentBuilds.length < 1) {
            log_1.default.error(chalk_1.default.bold(`Couldn't find any ${platform_1.appPlatformDisplayNames[appPlatform]} builds for this project on EAS servers. ` +
                "It looks like you haven't run 'eas build' yet."));
            return getArchiveAsync({
                ...source,
                sourceType: ArchiveSourceType.prompt,
            });
        }
        if (recentBuilds.every(it => new Date(it.updatedAt) < expiryDate)) {
            log_1.default.error(chalk_1.default.bold('It looks like all of your build artifacts have expired. ' +
                'EAS keeps your build artifacts only for 30 days.'));
            return getArchiveAsync({
                ...source,
                sourceType: ArchiveSourceType.prompt,
            });
        }
        const choices = recentBuilds.map(build => formatBuildChoice(build, expiryDate));
        choices.push({
            title: 'None of the above (select another option)',
            value: null,
        });
        const { selectedBuild } = await (0, prompts_1.promptAsync)({
            name: 'selectedBuild',
            type: 'select',
            message: 'Which build would you like to submit?',
            choices: choices.map(choice => ({ ...choice, title: `- ${choice.title}` })),
            warn: 'This artifact has expired',
        });
        if (selectedBuild == null) {
            return getArchiveAsync({
                ...source,
                sourceType: ArchiveSourceType.prompt,
            });
        }
        return {
            build: selectedBuild,
            source,
        };
    }
    catch (err) {
        log_1.default.error(err);
        throw err;
    }
}
function formatBuildChoice(build, expiryDate) {
    const { id, platform, updatedAt, appVersion, sdkVersion, runtimeVersion, buildProfile, appBuildVersion, releaseChannel, initiatingActor, } = build;
    const formatValue = (field) => field ? chalk_1.default.bold(field) : chalk_1.default.dim('Unknown');
    const buildDate = new Date(updatedAt);
    const maybeRuntimeVersion = runtimeVersion ? `Runtime: ${formatValue(runtimeVersion)}` : null;
    const maybeSdkVersion = sdkVersion ? `SDK: ${formatValue(sdkVersion)}` : null;
    const appBuildVersionString = `${platform === generated_1.AppPlatform.Android ? 'Version code' : 'Build number'}: ${formatValue(appBuildVersion)}`;
    const title = [
        `ID: ${chalk_1.default.dim(id)}, Finished at: ${chalk_1.default.bold(buildDate.toLocaleString())}`,
        [
            `\tApp version: ${formatValue(appVersion)}, ${appBuildVersionString}`,
            maybeRuntimeVersion,
            maybeSdkVersion,
        ]
            .filter(it => it != null)
            .join(', '),
        `\tProfile: ${formatValue(buildProfile)}, Release channel: ${formatValue(releaseChannel)}`,
        `\tAuthored by: ${formatValue(initiatingActor === null || initiatingActor === void 0 ? void 0 : initiatingActor.displayName)}`,
    ].join('\n');
    return {
        title,
        value: build,
        disabled: buildDate < expiryDate,
    };
}
async function handlePromptSourceAsync(source) {
    const { sourceType: sourceTypeRaw } = await (0, prompts_1.promptAsync)({
        name: 'sourceType',
        type: 'select',
        message: 'What would you like to submit?',
        choices: [
            {
                title: 'Select a build from EAS',
                value: ArchiveSourceType.buildList,
            },
            { title: 'Provide a URL to the app archive', value: ArchiveSourceType.url },
            {
                title: 'Provide a path to a local app binary file',
                value: ArchiveSourceType.path,
            },
            {
                title: 'Provide a build ID to identify a build on EAS',
                value: ArchiveSourceType.buildId,
            },
        ],
    });
    const sourceType = sourceTypeRaw;
    switch (sourceType) {
        case ArchiveSourceType.url: {
            const url = await askForArchiveUrlAsync(source.platform);
            return getArchiveAsync({
                ...source,
                sourceType: ArchiveSourceType.url,
                url,
            });
        }
        case ArchiveSourceType.path: {
            const path = await askForArchivePathAsync(source.platform);
            return getArchiveAsync({
                ...source,
                sourceType: ArchiveSourceType.path,
                path,
            });
        }
        case ArchiveSourceType.buildList: {
            return getArchiveAsync({
                ...source,
                sourceType: ArchiveSourceType.buildList,
            });
        }
        case ArchiveSourceType.buildId: {
            const id = await askForBuildIdAsync();
            return getArchiveAsync({
                ...source,
                sourceType: ArchiveSourceType.buildId,
                id,
            });
        }
        default:
            throw new Error('This should never happen');
    }
}
async function askForArchiveUrlAsync(platform) {
    const isIos = platform === eas_build_job_1.Platform.IOS;
    const defaultArchiveUrl = `https://url.to/your/archive.${isIos ? 'ipa' : 'aab'}`;
    const { url } = await (0, prompts_1.promptAsync)({
        name: 'url',
        message: 'URL:',
        initial: defaultArchiveUrl,
        type: 'text',
        validate: (url) => {
            if (url === defaultArchiveUrl) {
                return 'That was just an example URL, meant to show you the format that we expect for the response.';
            }
            else if (!validateUrl(url)) {
                return `${url} does not conform to HTTP format`;
            }
            else {
                return true;
            }
        },
    });
    return url;
}
async function askForArchivePathAsync(platform) {
    const isIos = platform === eas_build_job_1.Platform.IOS;
    const defaultArchivePath = `/path/to/your/archive.${isIos ? 'ipa' : 'aab'}`;
    const { path } = await (0, prompts_1.promptAsync)({
        name: 'path',
        message: `Path to the app archive file (${isIos ? 'ipa' : 'aab or apk'}):`,
        initial: defaultArchivePath,
        type: 'text',
        // eslint-disable-next-line async-protect/async-suffix
        validate: async (path) => {
            if (path === defaultArchivePath) {
                return 'That was just an example path, meant to show you the format that we expect for the response.';
            }
            else if (!(await (0, files_1.isExistingFileAsync)(path))) {
                return `File ${path} doesn't exist.`;
            }
            else {
                return true;
            }
        },
    });
    return path;
}
async function askForBuildIdAsync() {
    const { id } = await (0, prompts_1.promptAsync)({
        name: 'id',
        message: 'Build ID:',
        type: 'text',
        validate: (val) => {
            if (!isUuidV4(val)) {
                return `${val} is not a valid ID`;
            }
            else {
                return true;
            }
        },
    });
    return id;
}
async function askIfUseBuildIdFromUrlAsync(source, buildId) {
    const { url } = source;
    log_1.default.warn(`It seems that you provided a build details page URL: ${url}`);
    log_1.default.warn('We expected to see the build artifact URL.');
    if (!source.nonInteractive) {
        const useAsBuildId = await (0, prompts_1.confirmAsync)({
            message: `Do you want to submit build ${buildId} instead?`,
        });
        if (useAsBuildId) {
            return true;
        }
        else {
            log_1.default.warn('The submission will most probably fail.');
        }
    }
    else {
        log_1.default.warn("Proceeding because you've run this command in non-interactive mode.");
    }
    return false;
}
function isBuildDetailsPage(url) {
    const maybeExpoUrl = url.match(/expo\.(dev|io).*\/builds\/(.{36}).*/);
    if (maybeExpoUrl) {
        const maybeBuildId = maybeExpoUrl[2];
        if (isUuidV4(maybeBuildId)) {
            return maybeBuildId;
        }
        else {
            return false;
        }
    }
    else {
        return false;
    }
}
function validateUrl(url) {
    const protocols = ['http', 'https'];
    try {
        const parsed = new url_1.URL(url);
        return protocols
            ? parsed.protocol
                ? protocols.map(x => `${x.toLowerCase()}:`).includes(parsed.protocol)
                : false
            : true;
    }
    catch (err) {
        return false;
    }
}
function isUuidV4(s) {
    return uuid.validate(s) && uuid.version(s) === 4;
}
exports.isUuidV4 = isUuidV4;
