"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const events_1 = require("../../analytics/events");
const SubmissionMutation_1 = require("../../graphql/mutations/SubmissionMutation");
const formatFields_1 = tslib_1.__importDefault(require("../../utils/formatFields"));
const ArchiveSource_1 = require("../ArchiveSource");
const BaseSubmitter_1 = tslib_1.__importDefault(require("../BaseSubmitter"));
const summary_1 = require("../utils/summary");
const ServiceAccountSource_1 = require("./ServiceAccountSource");
class AndroidSubmitter extends BaseSubmitter_1.default {
    constructor(ctx, options) {
        const sourceOptionsResolver = {
            // eslint-disable-next-line async-protect/async-suffix
            archive: async () => await (0, ArchiveSource_1.getArchiveAsync)(this.options.archiveSource),
            // eslint-disable-next-line async-protect/async-suffix
            serviceAccountKeyResult: async () => {
                return await (0, ServiceAccountSource_1.getServiceAccountKeyResultAsync)(this.ctx, this.options.serviceAccountSource);
            },
        };
        const sourceOptionsAnalytics = {
            archive: {
                attemptEvent: events_1.SubmissionEvent.GATHER_ARCHIVE_ATTEMPT,
                successEvent: events_1.SubmissionEvent.GATHER_ARCHIVE_SUCCESS,
                failureEvent: events_1.SubmissionEvent.GATHER_ARCHIVE_FAIL,
            },
            serviceAccountKeyResult: {
                attemptEvent: events_1.SubmissionEvent.GATHER_CREDENTIALS_ATTEMPT,
                successEvent: events_1.SubmissionEvent.GATHER_CREDENTIALS_SUCCESS,
                failureEvent: events_1.SubmissionEvent.GATHER_CREDENTIALS_FAIL,
            },
        };
        super(ctx, options, sourceOptionsResolver, sourceOptionsAnalytics);
    }
    async createSubmissionInputAsync(resolvedSourceOptions) {
        var _a;
        const submissionConfig = await this.formatSubmissionConfig(this.options, resolvedSourceOptions);
        (0, summary_1.printSummary)(this.prepareSummaryData(this.options, resolvedSourceOptions), SummaryHumanReadableKeys);
        return {
            projectId: this.options.projectId,
            submissionConfig,
            buildId: (_a = resolvedSourceOptions.archive.build) === null || _a === void 0 ? void 0 : _a.id,
        };
    }
    async createPlatformSubmissionAsync({ projectId, submissionConfig, buildId, }) {
        return await SubmissionMutation_1.SubmissionMutation.createAndroidSubmissionAsync({
            appId: projectId,
            config: submissionConfig,
            submittedBuildId: buildId,
        });
    }
    formatSubmissionConfig(options, { archive, serviceAccountKeyResult }) {
        const { track, releaseStatus, changesNotSentForReview } = options;
        return {
            archiveUrl: archive.url,
            track,
            changesNotSentForReview,
            releaseStatus,
            ...serviceAccountKeyResult.result,
        };
    }
    prepareSummaryData(options, { archive, serviceAccountKeyResult }) {
        const { projectId, track, releaseStatus, changesNotSentForReview } = options;
        // structuring order affects table rows order
        return {
            projectId,
            track,
            changesNotSentForReview: changesNotSentForReview !== null && changesNotSentForReview !== void 0 ? changesNotSentForReview : undefined,
            releaseStatus: releaseStatus !== null && releaseStatus !== void 0 ? releaseStatus : undefined,
            formattedServiceAccount: formatServiceAccountSummary(serviceAccountKeyResult),
            ...(0, summary_1.formatArchiveSourceSummary)(archive),
        };
    }
}
exports.default = AndroidSubmitter;
const SummaryHumanReadableKeys = {
    archivePath: 'Archive path',
    archiveUrl: 'Download URL',
    changesNotSentForReview: 'Changes not sent for a review',
    formattedBuild: 'Build',
    formattedServiceAccount: 'Google Service Account Key',
    projectId: 'Project ID',
    releaseStatus: 'Release status',
    track: 'Release track',
};
function formatServiceAccountSummary({ summary }) {
    const { email: serviceAccountEmail, path: serviceAccountKeyPath, source: serviceAccountKeySource, } = summary;
    const fields = [
        {
            label: 'Key Source',
            value: serviceAccountKeySource,
        },
        {
            label: 'Key Path',
            value: serviceAccountKeyPath,
        },
        {
            label: 'Account E-mail',
            value: serviceAccountEmail,
        },
    ];
    const filteredFields = fields.filter(({ value }) => value !== undefined && value !== null);
    return ('\n' +
        (0, formatFields_1.default)(filteredFields, {
            labelFormat: label => `    ${chalk_1.default.dim(label)}:`,
        }));
}
