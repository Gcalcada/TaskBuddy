"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const eas_build_job_1 = require("@expo/eas-build-job");
const eas_json_1 = require("@expo/eas-json");
const results_1 = require("@expo/results");
const generated_1 = require("../../graphql/generated");
const log_1 = tslib_1.__importDefault(require("../../log"));
const applicationId_1 = require("../../project/android/applicationId");
const capitalize_1 = tslib_1.__importDefault(require("../../utils/expodash/capitalize"));
const commons_1 = require("../commons");
const AndroidSubmitter_1 = tslib_1.__importDefault(require("./AndroidSubmitter"));
const ServiceAccountSource_1 = require("./ServiceAccountSource");
class AndroidSubmitCommand {
    constructor(ctx) {
        this.ctx = ctx;
    }
    async runAsync() {
        log_1.default.addNewLineIfNone();
        const submissionOptions = await this.getAndroidSubmissionOptionsAsync();
        const submitter = new AndroidSubmitter_1.default(this.ctx, submissionOptions);
        return await submitter.submitAsync();
    }
    async getAndroidSubmissionOptionsAsync() {
        const track = this.resolveTrack();
        const releaseStatus = this.resolveReleaseStatus();
        const archiveSource = this.resolveArchiveSource();
        const serviceAccountSource = await this.resolveServiceAccountSourceAsync();
        const errored = [track, releaseStatus, archiveSource, serviceAccountSource].filter(r => !r.ok);
        if (errored.length > 0) {
            const message = errored.map(err => { var _a; return (_a = err.reason) === null || _a === void 0 ? void 0 : _a.message; }).join('\n');
            log_1.default.error(message);
            throw new Error('Submission failed');
        }
        return {
            projectId: this.ctx.projectId,
            track: track.enforceValue(),
            releaseStatus: releaseStatus.enforceValue(),
            archiveSource: archiveSource.enforceValue(),
            serviceAccountSource: serviceAccountSource.enforceValue(),
            changesNotSentForReview: this.ctx.profile.changesNotSentForReview,
        };
    }
    async maybeGetAndroidPackageFromCurrentProjectAsync() {
        try {
            return (0, results_1.result)(await (0, applicationId_1.getApplicationIdAsync)(this.ctx.projectDir, this.ctx.exp));
        }
        catch (error) {
            if (error instanceof applicationId_1.AmbiguousApplicationIdError) {
                log_1.default.warn('"applicationId" is ambiguous, specify it via "applicationId" field in the submit profile in the eas.json.');
                return (0, results_1.result)(null);
            }
            return (0, results_1.result)(new Error(`Failed to resolve applicationId in Android project: ${error.message}.`));
        }
    }
    resolveTrack() {
        const { track } = this.ctx.profile;
        if (!track) {
            return (0, results_1.result)(generated_1.SubmissionAndroidTrack.Internal);
        }
        const capitalizedTrack = (0, capitalize_1.default)(track);
        if (capitalizedTrack in generated_1.SubmissionAndroidTrack) {
            return (0, results_1.result)(generated_1.SubmissionAndroidTrack[capitalizedTrack]);
        }
        else {
            return (0, results_1.result)(new Error(`Unsupported track: ${track} (valid options: ${Object.keys(eas_json_1.AndroidReleaseTrack).join(', ')})`));
        }
    }
    resolveReleaseStatus() {
        const { releaseStatus } = this.ctx.profile;
        if (!releaseStatus) {
            return (0, results_1.result)(generated_1.SubmissionAndroidReleaseStatus.Completed);
        }
        const capitalizedReleaseStatus = (0, capitalize_1.default)(releaseStatus);
        if (capitalizedReleaseStatus in generated_1.SubmissionAndroidReleaseStatus) {
            return (0, results_1.result)(generated_1.SubmissionAndroidReleaseStatus[capitalizedReleaseStatus]);
        }
        else {
            return (0, results_1.result)(new Error(`Unsupported release status: ${releaseStatus} (valid options: ${Object.keys(eas_json_1.AndroidReleaseStatus).join(', ')})`));
        }
    }
    resolveArchiveSource() {
        try {
            return (0, results_1.result)((0, commons_1.resolveArchiveSource)(this.ctx, eas_build_job_1.Platform.ANDROID));
        }
        catch (err) {
            return (0, results_1.result)(err);
        }
    }
    async resolveServiceAccountSourceAsync() {
        var _a;
        const { serviceAccountKeyPath } = this.ctx.profile;
        if (serviceAccountKeyPath) {
            return (0, results_1.result)({
                sourceType: ServiceAccountSource_1.ServiceAccountSourceType.path,
                path: serviceAccountKeyPath,
            });
        }
        let androidApplicationIdentifier = (_a = this.ctx.applicationIdentifierOverride) !== null && _a !== void 0 ? _a : this.ctx.profile.applicationId;
        if (!androidApplicationIdentifier) {
            const androidApplicationIdentifierResult = await this.maybeGetAndroidPackageFromCurrentProjectAsync();
            if (!androidApplicationIdentifierResult.ok) {
                return (0, results_1.result)(androidApplicationIdentifierResult.reason);
            }
            const androidApplicationIdentifierValue = androidApplicationIdentifierResult.enforceValue();
            if (androidApplicationIdentifierValue) {
                androidApplicationIdentifier = androidApplicationIdentifierValue;
            }
        }
        return (0, results_1.result)({
            sourceType: ServiceAccountSource_1.ServiceAccountSourceType.credentialsService,
            androidApplicationIdentifier,
        });
    }
}
exports.default = AndroidSubmitCommand;
