"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const events_1 = require("../../analytics/events");
const SubmissionMutation_1 = require("../../graphql/mutations/SubmissionMutation");
const formatFields_1 = tslib_1.__importDefault(require("../../utils/formatFields"));
const ArchiveSource_1 = require("../ArchiveSource");
const BaseSubmitter_1 = tslib_1.__importDefault(require("../BaseSubmitter"));
const summary_1 = require("../utils/summary");
const AppSpecificPasswordSource_1 = require("./AppSpecificPasswordSource");
const AscApiKeySource_1 = require("./AscApiKeySource");
const CredentialsServiceSource_1 = require("./CredentialsServiceSource");
class IosSubmitter extends BaseSubmitter_1.default {
    constructor(ctx, options) {
        const sourceOptionsResolver = {
            // eslint-disable-next-line async-protect/async-suffix
            archive: async () => await (0, ArchiveSource_1.getArchiveAsync)(this.options.archiveSource),
            // eslint-disable-next-line async-protect/async-suffix
            credentials: async () => {
                const maybeAppSpecificPassword = this.options.appSpecificPasswordSource
                    ? await (0, AppSpecificPasswordSource_1.getAppSpecificPasswordLocallyAsync)(this.ctx, this.options.appSpecificPasswordSource)
                    : null;
                const maybeAppStoreConnectApiKey = this.options.ascApiKeySource
                    ? await (0, AscApiKeySource_1.getAscApiKeyLocallyAsync)(this.ctx, this.options.ascApiKeySource)
                    : null;
                const maybeAscOrAspFromCredentialsService = this.options.credentialsServiceSource
                    ? await (0, CredentialsServiceSource_1.getFromCredentialsServiceAsync)(this.ctx, this.options.credentialsServiceSource)
                    : null;
                return {
                    ...(maybeAppSpecificPassword ? { appSpecificPassword: maybeAppSpecificPassword } : null),
                    ...(maybeAppStoreConnectApiKey ? { ascApiKeyResult: maybeAppStoreConnectApiKey } : null),
                    ...(maybeAscOrAspFromCredentialsService ? maybeAscOrAspFromCredentialsService : null),
                };
            },
        };
        const sourceOptionsAnalytics = {
            archive: {
                attemptEvent: events_1.SubmissionEvent.GATHER_ARCHIVE_ATTEMPT,
                successEvent: events_1.SubmissionEvent.GATHER_ARCHIVE_SUCCESS,
                failureEvent: events_1.SubmissionEvent.GATHER_ARCHIVE_FAIL,
            },
            credentials: {
                attemptEvent: events_1.SubmissionEvent.GATHER_CREDENTIALS_ATTEMPT,
                successEvent: events_1.SubmissionEvent.GATHER_CREDENTIALS_SUCCESS,
                failureEvent: events_1.SubmissionEvent.GATHER_CREDENTIALS_FAIL,
            },
        };
        super(ctx, options, sourceOptionsResolver, sourceOptionsAnalytics);
    }
    async createSubmissionInputAsync(resolvedSourceOptions) {
        var _a;
        const submissionConfig = this.formatSubmissionConfig(this.options, resolvedSourceOptions);
        (0, summary_1.printSummary)(this.prepareSummaryData(this.options, resolvedSourceOptions), SummaryHumanReadableKeys);
        return {
            projectId: this.options.projectId,
            submissionConfig,
            buildId: (_a = resolvedSourceOptions.archive.build) === null || _a === void 0 ? void 0 : _a.id,
        };
    }
    async createPlatformSubmissionAsync({ projectId, submissionConfig, buildId, }) {
        return await SubmissionMutation_1.SubmissionMutation.createIosSubmissionAsync({
            appId: projectId,
            config: submissionConfig,
            submittedBuildId: buildId,
        });
    }
    formatSubmissionConfig(options, { archive, credentials }) {
        const { appSpecificPassword, ascApiKeyResult } = credentials;
        const { appleIdUsername, ascAppIdentifier } = options;
        return {
            ascAppIdentifier,
            appleIdUsername,
            archiveUrl: archive.url,
            ...(appSpecificPassword ? this.formatAppSpecificPassword(appSpecificPassword) : null),
            ...((ascApiKeyResult === null || ascApiKeyResult === void 0 ? void 0 : ascApiKeyResult.result) ? this.formatAscApiKeyResult(ascApiKeyResult.result) : null),
        };
    }
    formatAppSpecificPassword(appSpecificPassword) {
        return {
            appleAppSpecificPassword: appSpecificPassword.password,
            appleIdUsername: appSpecificPassword.appleIdUsername,
        };
    }
    formatAscApiKeyResult(result) {
        return 'ascApiKeyId' in result
            ? { ascApiKeyId: result.ascApiKeyId }
            : {
                ascApiKey: {
                    keyP8: result.keyP8,
                    keyIdentifier: result.keyId,
                    issuerIdentifier: result.issuerId,
                },
            };
    }
    prepareSummaryData(options, { archive, credentials }) {
        const { ascApiKeyResult, appSpecificPassword } = credentials;
        const { ascAppIdentifier, projectId } = options;
        // structuring order affects table rows order
        return {
            ascAppIdentifier,
            projectId,
            ...(appSpecificPassword ? { appleIdUsername: appSpecificPassword.appleIdUsername } : null),
            ...(ascApiKeyResult ? { formattedAscApiKey: formatAscApiKeySummary(ascApiKeyResult) } : null),
            ...(0, summary_1.formatArchiveSourceSummary)(archive),
        };
    }
}
exports.default = IosSubmitter;
const SummaryHumanReadableKeys = {
    ascAppIdentifier: 'ASC App ID',
    appleIdUsername: 'Apple ID',
    projectId: 'Project ID',
    archiveUrl: 'Archive URL',
    archivePath: 'Archive Path',
    formattedBuild: 'Build',
    formattedAscApiKey: 'App Store Connect API Key',
};
function formatAscApiKeySummary({ summary }) {
    const { source, path, keyId, name } = summary;
    const fields = [
        {
            label: 'Key Name',
            value: name,
        },
        {
            label: 'Key ID',
            value: keyId,
        },
        {
            label: 'Key Source',
            value: source,
        },
        {
            label: 'Key Path',
            value: path,
        },
    ];
    const filteredFields = fields.filter(({ value }) => value !== undefined && value !== null);
    return ('\n' +
        (0, formatFields_1.default)(filteredFields, {
            labelFormat: label => `    ${chalk_1.default.dim(label)}:`,
        }));
}
