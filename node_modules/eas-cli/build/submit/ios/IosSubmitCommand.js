"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const eas_build_job_1 = require("@expo/eas-build-job");
const results_1 = require("@expo/results");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const getenv_1 = tslib_1.__importDefault(require("getenv"));
const wrap_ansi_1 = tslib_1.__importDefault(require("wrap-ansi"));
const errors_1 = require("../../credentials/errors");
const log_1 = tslib_1.__importStar(require("../../log"));
const bundleIdentifier_1 = require("../../project/ios/bundleIdentifier");
const commons_1 = require("../commons");
const AppProduce_1 = require("./AppProduce");
const AppSpecificPasswordSource_1 = require("./AppSpecificPasswordSource");
const AscApiKeySource_1 = require("./AscApiKeySource");
const CredentialsServiceSource_1 = require("./CredentialsServiceSource");
const IosSubmitter_1 = tslib_1.__importDefault(require("./IosSubmitter"));
class IosSubmitCommand {
    constructor(ctx) {
        this.ctx = ctx;
    }
    async runAsync() {
        log_1.default.addNewLineIfNone();
        const options = await this.resolveSubmissionOptionsAsync();
        const submitter = new IosSubmitter_1.default(this.ctx, options);
        return await submitter.submitAsync();
    }
    async resolveSubmissionOptionsAsync() {
        const archiveSource = this.resolveArchiveSource();
        const credentialsSource = await this.resolveCredentialSubmissionOptionsAsync();
        const maybeAppSpecificPasswordSource = 'appSpecificPasswordSource' in credentialsSource
            ? credentialsSource.appSpecificPasswordSource
            : null;
        const maybeAscApiKeySource = 'ascApiKeySource' in credentialsSource ? credentialsSource.ascApiKeySource : null;
        const maybeCredentialsServiceSource = 'credentialsServiceSource' in credentialsSource
            ? credentialsSource.credentialsServiceSource
            : null;
        const ascAppIdentifier = await this.resolveAscAppIdentifierAsync();
        const errored = [
            archiveSource,
            ...(maybeAppSpecificPasswordSource ? [maybeAppSpecificPasswordSource] : []),
            ...(maybeAscApiKeySource ? [maybeAscApiKeySource] : []),
            ...(maybeCredentialsServiceSource ? [maybeCredentialsServiceSource] : []),
            ascAppIdentifier,
        ].filter(r => !r.ok);
        if (errored.length > 0) {
            const message = errored.map(err => { var _a; return (_a = err.reason) === null || _a === void 0 ? void 0 : _a.message; }).join('\n');
            log_1.default.error(message);
            throw new Error('Submission failed');
        }
        return {
            projectId: this.ctx.projectId,
            ascAppIdentifier: ascAppIdentifier.enforceValue(),
            archiveSource: archiveSource.enforceValue(),
            ...(maybeAppSpecificPasswordSource
                ? {
                    appSpecificPasswordSource: maybeAppSpecificPasswordSource.enforceValue(),
                }
                : null),
            ...(maybeAscApiKeySource
                ? {
                    ascApiKeySource: maybeAscApiKeySource.enforceValue(),
                }
                : null),
            ...(maybeCredentialsServiceSource
                ? {
                    credentialsServiceSource: maybeCredentialsServiceSource.enforceValue(),
                }
                : null),
        };
    }
    async maybeGetIosBundleIdentifierAsync() {
        try {
            return (0, results_1.result)(await (0, bundleIdentifier_1.getBundleIdentifierAsync)(this.ctx.projectDir, this.ctx.exp));
        }
        catch (error) {
            if (error instanceof bundleIdentifier_1.AmbiguousBundleIdentifierError) {
                log_1.default.warn('bundleIdentifier in the Xcode project is ambiguous, specify it via "bundleIdentifier" field in the submit profile in the eas.json.');
                return (0, results_1.result)(null);
            }
            return (0, results_1.result)(new Error(`Failed to resolve bundleIdentifier in the Xcode project: ${error.message}.`));
        }
    }
    async resolveCredentialSubmissionOptionsAsync() {
        var _a;
        const ascApiKeySource = this.resolveAscApiKeySource();
        const shouldSkipAscApiKeySource = !ascApiKeySource.ok && ascApiKeySource.enforceError() instanceof errors_1.MissingCredentialsError;
        if (!shouldSkipAscApiKeySource) {
            return { ascApiKeySource };
        }
        const appSpecificPasswordSource = this.resolveAppSpecificPasswordSource();
        const shouldSkipAppSpecificPasswordSource = !appSpecificPasswordSource.ok &&
            appSpecificPasswordSource.enforceError() instanceof errors_1.MissingCredentialsError;
        if (!shouldSkipAppSpecificPasswordSource) {
            return { appSpecificPasswordSource: this.resolveAppSpecificPasswordSource() };
        }
        let bundleIdentifier = (_a = this.ctx.applicationIdentifierOverride) !== null && _a !== void 0 ? _a : this.ctx.profile.bundleIdentifier;
        if (!bundleIdentifier) {
            const bundleIdentifierResult = await this.maybeGetIosBundleIdentifierAsync();
            if (!bundleIdentifierResult.ok) {
                return {
                    credentialsServiceSource: (0, results_1.result)(bundleIdentifierResult.reason),
                };
            }
            const bundleIdentifierValue = bundleIdentifierResult.enforceValue();
            if (bundleIdentifierValue) {
                bundleIdentifier = bundleIdentifierValue;
            }
        }
        return {
            credentialsServiceSource: (0, results_1.result)({
                sourceType: CredentialsServiceSource_1.CREDENTIALS_SERVICE_SOURCE,
                bundleIdentifier,
            }),
        };
    }
    resolveAppSpecificPasswordSource() {
        const envAppSpecificPassword = getenv_1.default.string('EXPO_APPLE_APP_SPECIFIC_PASSWORD', '');
        if (envAppSpecificPassword) {
            return (0, results_1.result)({
                sourceType: AppSpecificPasswordSource_1.AppSpecificPasswordSourceType.userDefined,
                appSpecificPassword: envAppSpecificPassword,
            });
        }
        return (0, results_1.result)(new errors_1.MissingCredentialsError('The EXPO_APPLE_APP_SPECIFIC_PASSWORD environment variable must be set.'));
    }
    resolveAscApiKeySource() {
        const { ascApiKeyPath, ascApiKeyIssuerId, ascApiKeyId } = this.ctx.profile;
        if (ascApiKeyPath && ascApiKeyIssuerId && ascApiKeyId) {
            return (0, results_1.result)({
                sourceType: AscApiKeySource_1.AscApiKeySourceType.path,
                path: {
                    keyP8Path: ascApiKeyPath,
                    issuerId: ascApiKeyIssuerId,
                    keyId: ascApiKeyId,
                },
            });
        }
        // interpret this to mean the user had some intention of passing in ASC Api key
        if (ascApiKeyPath || ascApiKeyIssuerId || ascApiKeyId) {
            const message = `ascApiKeyPath, ascApiKeyIssuerId and ascApiKeyId must all be defined in eas.json`;
            // in non-interactive mode, we should fail
            if (this.ctx.nonInteractive) {
                throw new Error(message);
            }
            log_1.default.warn(message);
            return (0, results_1.result)({
                sourceType: AscApiKeySource_1.AscApiKeySourceType.prompt,
            });
        }
        return (0, results_1.result)(new errors_1.MissingCredentialsError('Set the ascApiKeyPath, ascApiKeyIssuerId and ascApiKeyId fields in eas.json.'));
    }
    resolveArchiveSource() {
        try {
            return (0, results_1.result)((0, commons_1.resolveArchiveSource)(this.ctx, eas_build_job_1.Platform.IOS));
        }
        catch (err) {
            return (0, results_1.result)(err);
        }
    }
    async resolveAscAppIdentifierAsync() {
        const { ascAppId } = this.ctx.profile;
        if (ascAppId) {
            return (0, results_1.result)(ascAppId);
        }
        else if (this.ctx.nonInteractive) {
            return (0, results_1.result)(new Error('Set ascAppId in the submit profile (eas.json) or re-run this command in interactive mode.'));
        }
        else {
            log_1.default.log((0, wrap_ansi_1.default)(`Ensuring your app exists on App Store Connect. This step can be skipped by providing ${chalk_1.default.bold(`ascAppId`)} in the submit profile. ${(0, log_1.learnMore)('https://expo.fyi/asc-app-id')}`, process.stdout.columns || 80));
            log_1.default.addNewLineIfNone();
            try {
                const { ascAppIdentifier } = await (0, AppProduce_1.ensureAppStoreConnectAppExistsAsync)(this.ctx);
                return (0, results_1.result)(ascAppIdentifier);
            }
            catch (err) {
                return (0, results_1.result)(err);
            }
        }
    }
}
exports.default = IosSubmitCommand;
