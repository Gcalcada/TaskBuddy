"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitToCompleteAsync = exports.submitAsync = void 0;
const tslib_1 = require("tslib");
const eas_build_job_1 = require("@expo/eas-build-job");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const common_1 = require("../analytics/common");
const events_1 = require("../analytics/events");
const generated_1 = require("../graphql/generated");
const log_1 = tslib_1.__importStar(require("../log"));
const platform_1 = require("../platform");
const AndroidSubmitCommand_1 = tslib_1.__importDefault(require("./android/AndroidSubmitCommand"));
const IosSubmitCommand_1 = tslib_1.__importDefault(require("./ios/IosSubmitCommand"));
const logs_1 = require("./utils/logs");
const wait_1 = require("./utils/wait");
async function submitAsync(ctx) {
    return await (0, common_1.withAnalyticsAsync)(async () => {
        const command = ctx.platform === eas_build_job_1.Platform.ANDROID
            ? new AndroidSubmitCommand_1.default(ctx)
            : new IosSubmitCommand_1.default(ctx);
        return command.runAsync();
    }, {
        attemptEvent: events_1.SubmissionEvent.SUBMIT_COMMAND_ATTEMPT,
        successEvent: events_1.SubmissionEvent.SUBMIT_COMMAND_SUCCESS,
        failureEvent: events_1.SubmissionEvent.SUBMIT_COMMAND_FAIL,
        trackingCtx: ctx.trackingCtx,
    });
}
exports.submitAsync = submitAsync;
async function waitToCompleteAsync(submissions, { verbose = false } = {}) {
    log_1.default.newLine();
    const completedSubmissions = await (0, wait_1.waitForSubmissionsEndAsync)(submissions);
    const moreSubmissions = completedSubmissions.length > 1;
    if (moreSubmissions) {
        log_1.default.newLine();
    }
    for (const submission of completedSubmissions) {
        if (moreSubmissions) {
            log_1.default.log(`${platform_1.appPlatformEmojis[submission.platform]} ${chalk_1.default.bold(`${platform_1.appPlatformDisplayNames[submission.platform]} submission`)}`);
        }
        if (submission.platform === generated_1.AppPlatform.Android) {
            printInstructionsForAndroidSubmission(submission);
        }
        else {
            printInstructionsForIosSubmission(submission);
        }
        await (0, logs_1.displayLogsAsync)(submission, { verbose, moreSubmissions });
        if (moreSubmissions) {
            log_1.default.newLine();
        }
    }
    exitWithNonZeroCodeIfSomeSubmissionsDidntFinish(completedSubmissions);
}
exports.waitToCompleteAsync = waitToCompleteAsync;
function printInstructionsForAndroidSubmission(submission) {
    if (submission.status === generated_1.SubmissionStatus.Finished) {
        log_1.default.addNewLineIfNone();
        log_1.default.log('All done!');
    }
}
function printInstructionsForIosSubmission(submission) {
    var _a, _b;
    if (submission.status === generated_1.SubmissionStatus.Finished) {
        const logMsg = [
            chalk_1.default.bold('Your binary has been successfully uploaded to App Store Connect!'),
            '- It is now being processed by Apple - you will receive an e-mail when the processing finishes.',
            '- It usually takes about 5-10 minutes depending on how busy Apple servers are.',
            // ascAppIdentifier should be always available for ios submissions but check it anyway
            ((_a = submission.iosConfig) === null || _a === void 0 ? void 0 : _a.ascAppIdentifier) &&
                `- When itâ€™s done, you can see your build here: ${(0, log_1.link)(`https://appstoreconnect.apple.com/apps/${(_b = submission.iosConfig) === null || _b === void 0 ? void 0 : _b.ascAppIdentifier}/appstore/ios`)}`,
        ].join('\n');
        log_1.default.addNewLineIfNone();
        log_1.default.log(logMsg);
    }
}
function exitWithNonZeroCodeIfSomeSubmissionsDidntFinish(submissions) {
    const nonFinishedSubmissions = submissions.filter(({ status }) => status !== generated_1.SubmissionStatus.Finished);
    if (nonFinishedSubmissions.length > 0) {
        process.exit(1);
    }
}
