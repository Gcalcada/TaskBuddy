"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppleConfigReader = exports.DEFAULT_WHATSNEW = void 0;
const tslib_1 = require("tslib");
const apple_utils_1 = require("@expo/apple-utils");
const uniq_1 = tslib_1.__importDefault(require("../../../utils/expodash/uniq"));
const date_1 = require("../../utils/date");
// TODO: find out if we can move this to default JSON schema normalization
exports.DEFAULT_WHATSNEW = 'Bug fixes and improved stability';
/**
 * Deserializes the metadata config schema into attributes for different models.
 * This uses version 0 of the config schema.
 */
class AppleConfigReader {
    constructor(schema) {
        this.schema = schema;
    }
    getAgeRating() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
        const attributes = this.schema.advisory;
        if (!attributes) {
            return null;
        }
        return {
            alcoholTobaccoOrDrugUseOrReferences: (_a = attributes.alcoholTobaccoOrDrugUseOrReferences) !== null && _a !== void 0 ? _a : apple_utils_1.Rating.NONE,
            contests: (_b = attributes.contests) !== null && _b !== void 0 ? _b : apple_utils_1.Rating.NONE,
            gamblingSimulated: (_c = attributes.gamblingSimulated) !== null && _c !== void 0 ? _c : apple_utils_1.Rating.NONE,
            horrorOrFearThemes: (_d = attributes.horrorOrFearThemes) !== null && _d !== void 0 ? _d : apple_utils_1.Rating.NONE,
            matureOrSuggestiveThemes: (_e = attributes.matureOrSuggestiveThemes) !== null && _e !== void 0 ? _e : apple_utils_1.Rating.NONE,
            medicalOrTreatmentInformation: (_f = attributes.medicalOrTreatmentInformation) !== null && _f !== void 0 ? _f : apple_utils_1.Rating.NONE,
            profanityOrCrudeHumor: (_g = attributes.profanityOrCrudeHumor) !== null && _g !== void 0 ? _g : apple_utils_1.Rating.NONE,
            sexualContentGraphicAndNudity: (_h = attributes.sexualContentGraphicAndNudity) !== null && _h !== void 0 ? _h : apple_utils_1.Rating.NONE,
            sexualContentOrNudity: (_j = attributes.sexualContentOrNudity) !== null && _j !== void 0 ? _j : apple_utils_1.Rating.NONE,
            violenceCartoonOrFantasy: (_k = attributes.violenceCartoonOrFantasy) !== null && _k !== void 0 ? _k : apple_utils_1.Rating.NONE,
            violenceRealistic: (_l = attributes.violenceRealistic) !== null && _l !== void 0 ? _l : apple_utils_1.Rating.NONE,
            violenceRealisticProlongedGraphicOrSadistic: (_m = attributes.violenceRealisticProlongedGraphicOrSadistic) !== null && _m !== void 0 ? _m : apple_utils_1.Rating.NONE,
            gambling: (_o = attributes.gambling) !== null && _o !== void 0 ? _o : false,
            unrestrictedWebAccess: (_p = attributes.unrestrictedWebAccess) !== null && _p !== void 0 ? _p : false,
            kidsAgeBand: (_q = attributes.kidsAgeBand) !== null && _q !== void 0 ? _q : null,
            seventeenPlus: (_r = attributes.seventeenPlus) !== null && _r !== void 0 ? _r : false,
        };
    }
    getLocales() {
        // TODO: filter "default" locales, add option to add non-localized info to the config
        return (0, uniq_1.default)(Object.keys(this.schema.info || {}));
    }
    getInfoLocale(locale) {
        var _a;
        const info = (_a = this.schema.info) === null || _a === void 0 ? void 0 : _a[locale];
        if (!info) {
            return null;
        }
        return {
            locale,
            name: info.title,
            subtitle: info.subtitle,
            privacyChoicesUrl: info.privacyChoicesUrl,
            privacyPolicyText: info.privacyPolicyText,
            privacyPolicyUrl: info.privacyPolicyUrl,
        };
    }
    getCategories() {
        const { categories } = this.schema;
        if (!categories || categories.length <= 0) {
            return null;
        }
        // We validate the categories based on enums, but they will still be strings here.
        const categoryIds = {};
        if (Array.isArray(categories[0])) {
            categoryIds.primaryCategory = categories[0][0];
            categoryIds.primarySubcategoryOne = categories[0][1];
            categoryIds.primarySubcategoryTwo = categories[0][2];
        }
        else {
            categoryIds.primaryCategory = categories[0];
        }
        if (Array.isArray(categories[1])) {
            categoryIds.secondaryCategory = categories[1][0];
            categoryIds.secondarySubcategoryOne = categories[1][1];
            categoryIds.secondarySubcategoryTwo = categories[1][2];
        }
        else {
            categoryIds.secondaryCategory = categories[1];
        }
        // Because we handle categories as normal strings,
        // the type doesn't match with the actual CategoryIds types.
        return categoryIds;
    }
    /** Get the `AppStoreVersion` object. */
    getVersion() {
        var _a, _b;
        const attributes = {
            versionString: (_a = this.schema.version) !== null && _a !== void 0 ? _a : '',
            copyright: (_b = this.schema.copyright) !== null && _b !== void 0 ? _b : null,
        };
        const hasValues = Object.values(attributes).some(Boolean);
        return hasValues ? attributes : null;
    }
    getVersionReleaseType() {
        var _a, _b;
        const { release } = this.schema;
        if (typeof (release === null || release === void 0 ? void 0 : release.automaticRelease) === 'string') {
            return {
                releaseType: apple_utils_1.ReleaseType.SCHEDULED,
                // Convert time format to 2020-06-17T12:00:00-07:00, if that fails, try the date anyways.
                earliestReleaseDate: (_b = (_a = (0, date_1.removeDatePrecision)(release.automaticRelease)) === null || _a === void 0 ? void 0 : _a.toISOString()) !== null && _b !== void 0 ? _b : release.automaticRelease,
            };
        }
        if ((release === null || release === void 0 ? void 0 : release.automaticRelease) === true) {
            return {
                releaseType: apple_utils_1.ReleaseType.AFTER_APPROVAL,
                earliestReleaseDate: null,
            };
        }
        if ((release === null || release === void 0 ? void 0 : release.automaticRelease) === false) {
            return {
                releaseType: apple_utils_1.ReleaseType.MANUAL,
                earliestReleaseDate: null,
            };
        }
        return null;
    }
    getVersionReleasePhased() {
        var _a;
        if (((_a = this.schema.release) === null || _a === void 0 ? void 0 : _a.phasedRelease) === true) {
            return {
                phasedReleaseState: apple_utils_1.PhasedReleaseState.ACTIVE,
            };
        }
        // When phased release is turned off, we need to delete the phased release request.
        // There is no concept (yet) of pausing the phased release through EAS metadata.
        return null;
    }
    getVersionLocale(locale, context) {
        var _a, _b;
        const info = (_a = this.schema.info) === null || _a === void 0 ? void 0 : _a[locale];
        if (!info) {
            return null;
        }
        return {
            locale,
            description: info.description,
            keywords: (_b = info.keywords) === null || _b === void 0 ? void 0 : _b.join(','),
            // TODO: maybe move this to task logic, it's more an exception than data handling
            whatsNew: context.versionIsFirst ? undefined : info.releaseNotes || exports.DEFAULT_WHATSNEW,
            marketingUrl: info.marketingUrl,
            promotionalText: info.promoText,
            supportUrl: info.supportUrl,
        };
    }
    getReviewDetails() {
        const review = this.schema.review;
        if (!review) {
            return null;
        }
        return {
            contactFirstName: review.firstName,
            contactLastName: review.lastName,
            contactEmail: review.email,
            contactPhone: review.phone,
            demoAccountName: review.demoUsername,
            demoAccountPassword: review.demoPassword,
            demoAccountRequired: review.demoRequired,
            notes: review.notes,
            // TODO: add attachment
        };
    }
}
exports.AppleConfigReader = AppleConfigReader;
