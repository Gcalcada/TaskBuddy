"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkManifestBodyAgainstUpdateInfoGroup = exports.signManifestBody = exports.getManifestBodyAsync = exports.parseMultipartMixedResponseAsync = exports.getKeyAndCertificateFromPathsAsync = exports.getCodeSigningInfoAsync = void 0;
const tslib_1 = require("tslib");
const code_signing_certificates_1 = require("@expo/code-signing-certificates");
const dicer_1 = tslib_1.__importDefault(require("dicer"));
const fast_deep_equal_1 = tslib_1.__importDefault(require("fast-deep-equal"));
const fs_1 = require("fs");
const nullthrows_1 = tslib_1.__importDefault(require("nullthrows"));
const path_1 = tslib_1.__importDefault(require("path"));
const stream_1 = require("stream");
const structured_headers_1 = require("structured-headers");
async function getCodeSigningInfoAsync(config, privateKeyPath) {
    var _a, _b;
    const codeSigningCertificatePath = (_a = config.updates) === null || _a === void 0 ? void 0 : _a.codeSigningCertificate;
    if (!codeSigningCertificatePath) {
        return undefined;
    }
    if (!privateKeyPath) {
        privateKeyPath = path_1.default.join(path_1.default.dirname(codeSigningCertificatePath), 'private-key.pem');
    }
    const codeSigningMetadata = (_b = config.updates) === null || _b === void 0 ? void 0 : _b.codeSigningMetadata;
    if (!codeSigningMetadata) {
        throw new Error('Must specify codeSigningMetadata under the "updates" field of your app config file to use EAS code signing');
    }
    const { alg, keyid } = codeSigningMetadata;
    if (!alg || !keyid) {
        throw new Error('Must specify keyid and alg in the codeSigningMetadata field under the "updates" field of your app config file to use EAS code signing');
    }
    return codeSigningCertificatePath && privateKeyPath
        ? {
            ...(await getKeyAndCertificateFromPathsAsync({
                codeSigningCertificatePath,
                privateKeyPath,
            })),
            codeSigningMetadata: {
                alg,
                keyid,
            },
        }
        : undefined;
}
exports.getCodeSigningInfoAsync = getCodeSigningInfoAsync;
async function readFileAsync(path, errorMessage) {
    try {
        return await fs_1.promises.readFile(path, 'utf8');
    }
    catch {
        throw new Error(errorMessage);
    }
}
async function getKeyAndCertificateFromPathsAsync({ codeSigningCertificatePath, privateKeyPath, }) {
    const [codeSigningCertificatePEM, privateKeyPEM] = await Promise.all([
        readFileAsync(codeSigningCertificatePath, `Code signing certificate cannot be read from path: ${codeSigningCertificatePath}`),
        readFileAsync(privateKeyPath, `Code signing private key cannot be read from path: ${privateKeyPath}`),
    ]);
    const privateKey = (0, code_signing_certificates_1.convertPrivateKeyPEMToPrivateKey)(privateKeyPEM);
    const certificate = (0, code_signing_certificates_1.convertCertificatePEMToCertificate)(codeSigningCertificatePEM);
    (0, code_signing_certificates_1.validateSelfSignedCertificate)(certificate, {
        publicKey: certificate.publicKey,
        privateKey,
    });
    return {
        privateKey,
        certificate,
    };
}
exports.getKeyAndCertificateFromPathsAsync = getKeyAndCertificateFromPathsAsync;
async function parseMultipartMixedResponseAsync(res) {
    var _a;
    const contentType = res.headers.get('content-type');
    if (!contentType) {
        throw new Error('The multipart manifest response is missing the content-type header');
    }
    const boundaryRegex = /^multipart\/.+?; boundary=(?:"([^"]+)"|([^\s;]+))/i;
    const matches = boundaryRegex.exec(contentType);
    if (!matches) {
        throw new Error('The content-type header in the HTTP response is not a multipart media type');
    }
    const boundary = (_a = matches[1]) !== null && _a !== void 0 ? _a : matches[2];
    const bodyBuffer = await res.arrayBuffer();
    const bufferStream = new stream_1.Stream.PassThrough();
    bufferStream.end(bodyBuffer);
    return await new Promise((resolve, reject) => {
        const parts = [];
        bufferStream.pipe(new dicer_1.default({ boundary })
            .on('part', p => {
            const part = {
                body: '',
                headers: new Map(),
            };
            p.on('header', headers => {
                for (const h in headers) {
                    part.headers.set(h, headers[h][0]);
                }
            });
            p.on('data', data => {
                part.body += data.toString();
            });
            p.on('end', () => {
                parts.push(part);
            });
        })
            .on('finish', () => {
            resolve(parts);
        })
            .on('error', error => {
            reject(error);
        }));
    });
}
exports.parseMultipartMixedResponseAsync = parseMultipartMixedResponseAsync;
function isManifestMultipartPart(multipartPart) {
    const [, parameters] = (0, structured_headers_1.parseItem)((0, nullthrows_1.default)(multipartPart.headers.get('content-disposition')));
    const partName = parameters.get('name');
    return partName === 'manifest';
}
async function getManifestBodyAsync(res) {
    var _a;
    const multipartParts = await parseMultipartMixedResponseAsync(res);
    const manifestPart = multipartParts.find(isManifestMultipartPart);
    return (_a = manifestPart === null || manifestPart === void 0 ? void 0 : manifestPart.body) !== null && _a !== void 0 ? _a : null;
}
exports.getManifestBodyAsync = getManifestBodyAsync;
function signManifestBody(body, codeSigningInfo) {
    return (0, code_signing_certificates_1.signStringRSASHA256AndVerify)(codeSigningInfo.privateKey, codeSigningInfo.certificate, body);
}
exports.signManifestBody = signManifestBody;
function assertAssetParity(manifestResponseBodyAssetJSON, partialManifestAsset) {
    const baseErrorMessage = `Code signing manifest integrity error: Manifest asset tamper detected for asset: ${partialManifestAsset.bundleKey}; field: `;
    if (manifestResponseBodyAssetJSON.hash !== partialManifestAsset.fileSHA256) {
        throw new Error(baseErrorMessage + 'hash');
    }
    if (manifestResponseBodyAssetJSON.contentType !== partialManifestAsset.contentType) {
        throw new Error(baseErrorMessage + 'contentType');
    }
    if (manifestResponseBodyAssetJSON.key !== partialManifestAsset.bundleKey) {
        throw new Error(baseErrorMessage + 'key');
    }
}
function checkManifestBodyAgainstUpdateInfoGroup(manifestResponseBody, partialManifest) {
    var _a, _b;
    const manifestResponseBodyJSON = JSON.parse(manifestResponseBody);
    // Assert expoClient config is equal. We do not want to sign the manifest if the
    // server has compromised the integrity of the manifest.
    // JSON stringify and unstringify to remove any undefined values and bring it as close
    // to the server sanitized value as possible
    const isExtraEqual = (0, fast_deep_equal_1.default)(JSON.parse(JSON.stringify((_a = partialManifest.extra) === null || _a === void 0 ? void 0 : _a.expoClient)), (_b = manifestResponseBodyJSON.extra) === null || _b === void 0 ? void 0 : _b.expoClient);
    if (!isExtraEqual) {
        throw new Error(`Code signing manifest integrity error: The manifest being signed contains an extra.expoClient field that does not match the initially uploaded manifest's extra.expoClient field`);
    }
    assertAssetParity(manifestResponseBodyJSON.launchAsset, partialManifest.launchAsset);
    if (manifestResponseBodyJSON.assets.length !== partialManifest.assets.length) {
        throw new Error('Code signing manifest integrity error: The manifest being signed has an assets array of differing length from the initially uploaded manifest');
    }
    for (const partialManifestAsset of partialManifest.assets) {
        const partialManifestAssetBundleKey = (0, nullthrows_1.default)(partialManifestAsset).bundleKey;
        const correspondingManifestResponseBodyAssetJSON = manifestResponseBodyJSON.assets.find((manifestResponseBodyAssetJSON) => manifestResponseBodyAssetJSON.key === partialManifestAssetBundleKey);
        if (!correspondingManifestResponseBodyAssetJSON) {
            throw new Error(`Code signing manifest integrity error: The manifest being signed has is missing an asset specified in the initially uploaded manifest: ${partialManifestAssetBundleKey}`);
        }
        assertAssetParity(correspondingManifestResponseBodyAssetJSON, (0, nullthrows_1.default)(partialManifestAsset));
    }
}
exports.checkManifestBodyAgainstUpdateInfoGroup = checkManifestBodyAgainstUpdateInfoGroup;
