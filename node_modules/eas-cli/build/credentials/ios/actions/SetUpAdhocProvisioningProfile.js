"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.doUDIDsMatch = exports.SetUpAdhocProvisioningProfile = void 0;
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const nullthrows_1 = tslib_1.__importDefault(require("nullthrows"));
const action_1 = tslib_1.__importStar(require("../../../devices/actions/create/action"));
const generated_1 = require("../../../graphql/generated");
const log_1 = tslib_1.__importDefault(require("../../../log"));
const prompts_1 = require("../../../prompts");
const differenceBy_1 = tslib_1.__importDefault(require("../../../utils/expodash/differenceBy"));
const errors_1 = require("../../errors");
const validateProvisioningProfile_1 = require("../validators/validateProvisioningProfile");
const AppleTeamUtils_1 = require("./AppleTeamUtils");
const BuildCredentialsUtils_1 = require("./BuildCredentialsUtils");
const DeviceUtils_1 = require("./DeviceUtils");
const SetUpDistributionCertificate_1 = require("./SetUpDistributionCertificate");
var ReuseAction;
(function (ReuseAction) {
    ReuseAction[ReuseAction["Yes"] = 0] = "Yes";
    ReuseAction[ReuseAction["ShowDevices"] = 1] = "ShowDevices";
    ReuseAction[ReuseAction["No"] = 2] = "No";
})(ReuseAction || (ReuseAction = {}));
class SetUpAdhocProvisioningProfile {
    constructor(app) {
        this.app = app;
    }
    async runAsync(ctx) {
        const distCert = await new SetUpDistributionCertificate_1.SetUpDistributionCertificate(this.app, generated_1.IosDistributionType.AdHoc).runAsync(ctx);
        const areBuildCredentialsSetup = await this.areBuildCredentialsSetupAsync(ctx);
        if (ctx.nonInteractive) {
            if (areBuildCredentialsSetup) {
                return (0, nullthrows_1.default)(await (0, BuildCredentialsUtils_1.getBuildCredentialsAsync)(ctx, this.app, generated_1.IosDistributionType.AdHoc));
            }
            else {
                throw new errors_1.MissingCredentialsNonInteractiveError('Provisioning profile is not configured correctly. Please run this command again in interactive mode.');
            }
        }
        const currentBuildCredentials = await (0, BuildCredentialsUtils_1.getBuildCredentialsAsync)(ctx, this.app, generated_1.IosDistributionType.AdHoc);
        if (areBuildCredentialsSetup) {
            const buildCredentials = (0, nullthrows_1.default)(currentBuildCredentials);
            if (await this.shouldUseExistingProfileAsync(ctx, buildCredentials)) {
                return buildCredentials;
            }
        }
        return await this.runWithDistributionCertificateAsync(ctx, distCert);
    }
    async runWithDistributionCertificateAsync(ctx, distCert) {
        var _a, _b, _c, _d, _e;
        const currentBuildCredentials = await (0, BuildCredentialsUtils_1.getBuildCredentialsAsync)(ctx, this.app, generated_1.IosDistributionType.AdHoc);
        // 1. Resolve Apple Team
        let appleTeam = (_c = (_a = distCert.appleTeam) !== null && _a !== void 0 ? _a : (_b = currentBuildCredentials === null || currentBuildCredentials === void 0 ? void 0 : currentBuildCredentials.provisioningProfile) === null || _b === void 0 ? void 0 : _b.appleTeam) !== null && _c !== void 0 ? _c : null;
        if (!appleTeam) {
            await ctx.appStore.ensureAuthenticatedAsync();
            appleTeam = await (0, AppleTeamUtils_1.resolveAppleTeamIfAuthenticatedAsync)(ctx, this.app);
        }
        (0, assert_1.default)(appleTeam, 'Apple Team must be defined here');
        // 2. Fetch devices registered on EAS servers
        let registeredAppleDevices = await ctx.ios.getDevicesForAppleTeamAsync(this.app, appleTeam);
        if (registeredAppleDevices.length === 0) {
            const shouldRegisterDevices = await (0, prompts_1.confirmAsync)({
                message: `You don't have any registered devices yet. Would you like to register them now?`,
                initial: true,
            });
            if (shouldRegisterDevices) {
                registeredAppleDevices = await this.registerDevicesAsync(ctx, appleTeam);
            }
            else {
                throw new Error(`Run 'eas device:create' to register your devices first`);
            }
        }
        // 3. Choose devices for internal distribution
        const provisionedDeviceIdentifiers = ((_e = (_d = currentBuildCredentials === null || currentBuildCredentials === void 0 ? void 0 : currentBuildCredentials.provisioningProfile) === null || _d === void 0 ? void 0 : _d.appleDevices) !== null && _e !== void 0 ? _e : []).map(i => i.identifier);
        const chosenDevices = await (0, DeviceUtils_1.chooseDevicesAsync)(registeredAppleDevices, provisionedDeviceIdentifiers);
        // 4. Reuse or create the profile on Apple Developer Portal
        const provisioningProfileStoreInfo = await ctx.appStore.createOrReuseAdhocProvisioningProfileAsync(chosenDevices.map(({ identifier }) => identifier), this.app.bundleIdentifier, distCert.serialNumber);
        // 5. Create or update the profile on servers
        const appleAppIdentifier = await ctx.ios.createOrGetExistingAppleAppIdentifierAsync(this.app, appleTeam);
        let appleProvisioningProfile = null;
        if (currentBuildCredentials === null || currentBuildCredentials === void 0 ? void 0 : currentBuildCredentials.provisioningProfile) {
            if (currentBuildCredentials.provisioningProfile.developerPortalIdentifier !==
                provisioningProfileStoreInfo.provisioningProfileId) {
                await ctx.ios.deleteProvisioningProfilesAsync([
                    currentBuildCredentials.provisioningProfile.id,
                ]);
                appleProvisioningProfile = await ctx.ios.createProvisioningProfileAsync(this.app, appleAppIdentifier, {
                    appleProvisioningProfile: provisioningProfileStoreInfo.provisioningProfile,
                    developerPortalIdentifier: provisioningProfileStoreInfo.provisioningProfileId,
                });
            }
            else {
                appleProvisioningProfile = currentBuildCredentials.provisioningProfile;
            }
        }
        else {
            appleProvisioningProfile = await ctx.ios.createProvisioningProfileAsync(this.app, appleAppIdentifier, {
                appleProvisioningProfile: provisioningProfileStoreInfo.provisioningProfile,
                developerPortalIdentifier: provisioningProfileStoreInfo.provisioningProfileId,
            });
        }
        // 6. Create (or update) app build credentials
        (0, assert_1.default)(appleProvisioningProfile);
        return await (0, BuildCredentialsUtils_1.assignBuildCredentialsAsync)(ctx, this.app, generated_1.IosDistributionType.AdHoc, distCert, appleProvisioningProfile, appleTeam);
    }
    async areBuildCredentialsSetupAsync(ctx) {
        const buildCredentials = await (0, BuildCredentialsUtils_1.getBuildCredentialsAsync)(ctx, this.app, generated_1.IosDistributionType.AdHoc);
        return await (0, validateProvisioningProfile_1.validateProvisioningProfileAsync)(ctx, this.app, buildCredentials);
    }
    async shouldUseExistingProfileAsync(ctx, buildCredentials) {
        const provisioningProfile = (0, nullthrows_1.default)(buildCredentials.provisioningProfile);
        const appleTeam = (0, nullthrows_1.default)(provisioningProfile.appleTeam);
        const registeredAppleDevices = await ctx.ios.getDevicesForAppleTeamAsync(this.app, appleTeam);
        const provisionedDevices = provisioningProfile.appleDevices;
        const allRegisteredDevicesAreProvisioned = doUDIDsMatch(registeredAppleDevices.map(({ identifier }) => identifier), provisionedDevices.map(({ identifier }) => identifier));
        if (allRegisteredDevicesAreProvisioned) {
            const reuseAction = await this.promptForReuseActionAsync();
            if (reuseAction === ReuseAction.Yes) {
                return true;
            }
            else if (reuseAction === ReuseAction.No) {
                return false;
            }
            else {
                log_1.default.newLine();
                log_1.default.log('Devices registered in the Provisioning Profile:');
                for (const device of provisionedDevices) {
                    log_1.default.log(`- ${(0, DeviceUtils_1.formatDeviceLabel)(device)}`);
                }
                log_1.default.newLine();
                return ((await this.promptForReuseActionAsync({ showShowDevicesOption: false })) ===
                    ReuseAction.Yes);
            }
        }
        else {
            const missingDevices = (0, differenceBy_1.default)(registeredAppleDevices, provisionedDevices, 'identifier');
            log_1.default.warn(`The provisioning profile is missing the following devices:`);
            for (const missingDevice of missingDevices) {
                log_1.default.warn(`- ${(0, DeviceUtils_1.formatDeviceLabel)(missingDevice)}`);
            }
            return !(await (0, prompts_1.confirmAsync)({
                message: `Would you like to choose the devices to provision again?`,
                initial: true,
            }));
        }
    }
    async promptForReuseActionAsync({ showShowDevicesOption = true, } = {}) {
        const { selected } = await (0, prompts_1.promptAsync)({
            type: 'select',
            name: 'selected',
            message: `${showShowDevicesOption
                ? 'All your registered devices are present in the Provisioning Profile. '
                : ''}Would you like to reuse the profile?`,
            choices: [
                { title: 'Yes', value: ReuseAction.Yes },
                ...(showShowDevicesOption
                    ? [
                        {
                            title: 'Show devices and ask me again',
                            value: ReuseAction.ShowDevices,
                        },
                    ]
                    : []),
                {
                    title: 'No, let me choose devices again',
                    value: ReuseAction.No,
                },
            ],
        });
        return selected;
    }
    async registerDevicesAsync(ctx, appleTeam) {
        const action = new action_1.default(this.app.account, appleTeam);
        const method = await action.runAsync();
        while (true) {
            if (method !== action_1.RegistrationMethod.INPUT) {
                log_1.default.newLine();
                log_1.default.log(chalk_1.default.bold("Press any key if you've already finished device registration."));
                await (0, prompts_1.pressAnyKeyToContinueAsync)();
            }
            log_1.default.newLine();
            const devices = await ctx.ios.getDevicesForAppleTeamAsync(this.app, appleTeam, {
                useCache: false,
            });
            if (devices.length === 0) {
                log_1.default.warn('There are still no registered devices.');
                // if the user used the input method there should be some devices available
                if (method === action_1.RegistrationMethod.INPUT) {
                    throw new Error('Input registration method has failed');
                }
            }
            else {
                return devices;
            }
        }
    }
}
exports.SetUpAdhocProvisioningProfile = SetUpAdhocProvisioningProfile;
function doUDIDsMatch(udidsA, udidsB) {
    const setA = new Set(udidsA);
    const setB = new Set(udidsB);
    if (setA.size !== setB.size) {
        return false;
    }
    for (const a of setA) {
        if (!setB.has(a)) {
            return false;
        }
    }
    return true;
}
exports.doUDIDsMatch = doUDIDsMatch;
