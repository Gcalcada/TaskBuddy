"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CredentialsContext = void 0;
const tslib_1 = require("tslib");
const config_1 = require("@expo/config");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const log_1 = tslib_1.__importDefault(require("../log"));
const expoConfig_1 = require("../project/expoConfig");
const projectUtils_1 = require("../project/projectUtils");
const prompts_1 = require("../prompts");
const User_1 = require("../user/User");
const AndroidGraphqlClient = tslib_1.__importStar(require("./android/api/GraphqlClient"));
const IosGraphqlClient = tslib_1.__importStar(require("./ios/api/GraphqlClient"));
const AppStoreApi_1 = tslib_1.__importDefault(require("./ios/appstore/AppStoreApi"));
class CredentialsContext {
    constructor(options) {
        var _a, _b;
        this.options = options;
        this.android = AndroidGraphqlClient;
        this.appStore = new AppStoreApi_1.default();
        this.ios = IosGraphqlClient;
        this.shouldAskAuthenticateAppStore = true;
        this.projectDir = options.projectDir;
        this.user = options.user;
        this.nonInteractive = (_a = options.nonInteractive) !== null && _a !== void 0 ? _a : false;
        this.resolvedExp = options.exp;
        if (!this.resolvedExp) {
            this.resolvedExp =
                (_b = CredentialsContext.getExpoConfigInProject(this.projectDir, { env: options.env })) !== null && _b !== void 0 ? _b : undefined;
        }
    }
    static getExpoConfigInProject(projectDir, { env } = {}) {
        try {
            return (0, expoConfig_1.getExpoConfig)(projectDir, { env });
        }
        catch (error) {
            // ignore error, context might be created outside of expo project
            return null;
        }
    }
    get hasProjectContext() {
        return !!this.resolvedExp;
    }
    get exp() {
        this.ensureProjectContext();
        return this.resolvedExp;
    }
    ensureProjectContext() {
        if (this.hasProjectContext) {
            return;
        }
        // trigger getConfig error
        (0, config_1.getConfig)(this.options.projectDir, { skipSDKVersionRequirement: true });
    }
    logOwnerAndProject() {
        var _a;
        const { user } = this.options;
        if (this.hasProjectContext) {
            const owner = (0, projectUtils_1.getProjectAccountName)(this.exp, user);
            // Figure out if User A is configuring credentials as admin for User B's project
            const isProxyUser = user.__typename === 'Robot' || owner !== user.username;
            log_1.default.log(`Accessing credentials ${isProxyUser ? 'on behalf of' : 'for'} ${owner} in project ${this.exp.slug}`);
        }
        else {
            log_1.default.log(`Accessing credentials for ${(_a = this.exp.owner) !== null && _a !== void 0 ? _a : (0, User_1.getActorDisplayName)(user)}`);
        }
    }
    async bestEffortAppStoreAuthenticateAsync() {
        if (this.appStore.authCtx || !this.shouldAskAuthenticateAppStore) {
            // skip prompts if already have apple ctx or already asked about it
            return;
        }
        if (this.nonInteractive) {
            return;
        }
        log_1.default.log(chalk_1.default.green('If you provide your Apple account credentials we will be able to generate all necessary build credentials and fully validate them.'));
        log_1.default.log(chalk_1.default.green('This is optional, but without Apple account access you will need to provide all the missing values manually and we can only run minimal validation on them.'));
        const confirm = await (0, prompts_1.confirmAsync)({
            message: `Do you want to log in to your Apple account?`,
        });
        if (confirm) {
            await this.appStore.ensureAuthenticatedAsync();
        }
        else {
            log_1.default.log(chalk_1.default.green('No problem! ðŸ‘Œ If any of the next steps will require Apple account access we will ask you again about it.'));
        }
        this.shouldAskAuthenticateAppStore = false;
    }
}
exports.CredentialsContext = CredentialsContext;
