"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sortBuildCredentials = exports.promptForNameAsync = exports.createOrUpdateDefaultAndroidAppBuildCredentialsAsync = exports.getAppLookupParamsFromContextAsync = exports.promptUserAndCopyLegacyCredentialsAsync = exports.canCopyLegacyCredentialsAsync = void 0;
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const nanoid_1 = require("nanoid");
const ora_1 = require("../../../ora");
const applicationId_1 = require("../../../project/android/applicationId");
const projectUtils_1 = require("../../../project/projectUtils");
const prompts_1 = require("../../../prompts");
const Account_1 = require("../../../user/Account");
/**
 * Legacy credentials can be copied over to EAS if the user does not have
 * EAS credentials set up yet
 */
async function canCopyLegacyCredentialsAsync(ctx, app) {
    const appCredentials = await ctx.android.getAndroidAppCredentialsWithCommonFieldsAsync(app);
    if (appCredentials) {
        return false; // modern credentials already exist
    }
    const legacyAppCredentials = await ctx.android.getLegacyAndroidAppCredentialsWithCommonFieldsAsync(app);
    return !!legacyAppCredentials; // user has some legacy credentials
}
exports.canCopyLegacyCredentialsAsync = canCopyLegacyCredentialsAsync;
async function promptUserAndCopyLegacyCredentialsAsync(ctx, app) {
    var _a, _b;
    (0, assert_1.default)(await canCopyLegacyCredentialsAsync(ctx, app), 'User not eligible to copy classic build credentials to EAS');
    const spinner = (0, ora_1.ora)('Classic credentials detected, copying to EAS...').start();
    try {
        const legacyAppCredentials = await ctx.android.getLegacyAndroidAppCredentialsWithCommonFieldsAsync(app);
        if (!legacyAppCredentials) {
            return;
        }
        const appCredentials = await ctx.android.createOrGetExistingAndroidAppCredentialsWithBuildCredentialsAsync(app);
        const legacyFcm = legacyAppCredentials.androidFcm;
        if (legacyFcm) {
            const clonedFcm = await ctx.android.createFcmAsync(app.account, legacyFcm.credential, legacyFcm.version);
            await ctx.android.updateAndroidAppCredentialsAsync(appCredentials, {
                androidFcmId: clonedFcm.id,
            });
        }
        const legacyBuildCredentials = await ctx.android.getLegacyAndroidAppBuildCredentialsAsync(app);
        const legacyKeystore = (_a = legacyBuildCredentials === null || legacyBuildCredentials === void 0 ? void 0 : legacyBuildCredentials.androidKeystore) !== null && _a !== void 0 ? _a : null;
        if (legacyKeystore) {
            const clonedKeystore = await ctx.android.createKeystoreAsync(app.account, {
                keystore: legacyKeystore.keystore,
                keystorePassword: legacyKeystore.keystorePassword,
                keyAlias: legacyKeystore.keyAlias,
                keyPassword: (_b = legacyKeystore.keyPassword) !== null && _b !== void 0 ? _b : undefined,
                type: legacyKeystore.type,
            });
            await createOrUpdateDefaultAndroidAppBuildCredentialsAsync(ctx, app, {
                androidKeystoreId: clonedKeystore.id,
            });
        }
    }
    catch (e) {
        spinner.fail(`Unable to migrate credentials to EAS.`);
        throw e;
    }
    spinner.succeed('Credentials copied to EAS.');
}
exports.promptUserAndCopyLegacyCredentialsAsync = promptUserAndCopyLegacyCredentialsAsync;
async function getAppLookupParamsFromContextAsync(ctx, gradleContext) {
    ctx.ensureProjectContext();
    const projectName = ctx.exp.slug;
    const accountName = (0, projectUtils_1.getProjectAccountName)(ctx.exp, ctx.user);
    const account = (0, Account_1.findAccountByName)(ctx.user.accounts, accountName);
    if (!account) {
        throw new Error(`You do not have access to account: ${accountName}`);
    }
    const androidApplicationIdentifier = await (0, applicationId_1.getApplicationIdAsync)(ctx.projectDir, ctx.exp, gradleContext);
    if (!androidApplicationIdentifier) {
        throw new Error(`android.package needs to be defined in your ${(0, projectUtils_1.getProjectConfigDescription)(ctx.projectDir)} file`);
    }
    return { account, projectName, androidApplicationIdentifier };
}
exports.getAppLookupParamsFromContextAsync = getAppLookupParamsFromContextAsync;
async function createOrUpdateDefaultAndroidAppBuildCredentialsAsync(ctx, appLookupParams, { androidKeystoreId, }) {
    (0, assert_1.default)(!ctx.nonInteractive, 'createOrUpdateDefaultAndroidAppBuildCredentialsAsync must be run in interactive mode');
    const existingDefaultBuildCredentials = await ctx.android.getDefaultAndroidAppBuildCredentialsAsync(appLookupParams);
    if (existingDefaultBuildCredentials) {
        return await ctx.android.updateAndroidAppBuildCredentialsAsync(existingDefaultBuildCredentials, { androidKeystoreId });
    }
    return await ctx.android.createAndroidAppBuildCredentialsAsync(appLookupParams, {
        name: generateRandomName(),
        isDefault: true,
        androidKeystoreId,
    });
}
exports.createOrUpdateDefaultAndroidAppBuildCredentialsAsync = createOrUpdateDefaultAndroidAppBuildCredentialsAsync;
async function promptForNameAsync() {
    const { providedName } = await (0, prompts_1.promptAsync)({
        type: 'text',
        name: 'providedName',
        message: 'Assign a name to your build credentials:',
        initial: generateRandomName(),
        validate: (input) => input !== '',
    });
    return providedName;
}
exports.promptForNameAsync = promptForNameAsync;
/**
 * sort a build credentials array in descending order of preference
 * prefer default credentials, then prefer names that come first lexicographically
 */
function sortBuildCredentials(androidAppBuildCredentialsList) {
    return androidAppBuildCredentialsList.sort((buildCredentialsA, buildCredentialsB) => {
        if (buildCredentialsA.isDefault) {
            return -1;
        }
        else if (buildCredentialsB.isDefault) {
            return 1;
        }
        return buildCredentialsA.name.localeCompare(buildCredentialsB.name);
    });
}
exports.sortBuildCredentials = sortBuildCredentials;
function generateRandomName() {
    return `Build Credentials ${(0, nanoid_1.nanoid)(10)}`;
}
