"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseGradleCommand = exports.resolveConfigValue = exports.getAppBuildGradleAsync = exports.DEFAULT_MODULE_NAME = void 0;
const tslib_1 = require("tslib");
const config_plugins_1 = require("@expo/config-plugins");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const parser_1 = tslib_1.__importDefault(require("gradle-to-js/lib/parser"));
exports.DEFAULT_MODULE_NAME = 'app';
async function getAppBuildGradleAsync(projectDir) {
    const buildGradlePath = config_plugins_1.AndroidConfig.Paths.getAppBuildGradleFilePath(projectDir);
    const rawBuildGradle = await fs_extra_1.default.readFile(buildGradlePath, 'utf8');
    return await parser_1.default.parseText(rawBuildGradle);
}
exports.getAppBuildGradleAsync = getAppBuildGradleAsync;
function resolveConfigValue(buildGradle, field, flavor) {
    var _a, _b, _c, _d, _e, _f;
    return ((_d = (flavor && ((_c = (_b = (_a = buildGradle === null || buildGradle === void 0 ? void 0 : buildGradle.android) === null || _a === void 0 ? void 0 : _a.productFlavors) === null || _b === void 0 ? void 0 : _b[flavor]) === null || _c === void 0 ? void 0 : _c[field]))) !== null && _d !== void 0 ? _d : (_f = (_e = buildGradle === null || buildGradle === void 0 ? void 0 : buildGradle.android) === null || _e === void 0 ? void 0 : _e.defaultConfig) === null || _f === void 0 ? void 0 : _f[field]);
}
exports.resolveConfigValue = resolveConfigValue;
/**
 * Extract module name, buildType, and flavor from the gradle command.
 *
 * @param cmd can be any valid string that can be added after `./gradlew` call
 * e.g.
 *   - :app:buildDebug
 *   - app:buildDebug
 *   - buildDebug
 *   - buildDebug --console verbose
 * @param buildGradle is used to verify correct casing of the first letter in
 * the flavor name
 **/
function parseGradleCommand(cmd, buildGradle) {
    var _a, _b, _c, _d;
    const hasFlavorDimensions = ((_b = (_a = buildGradle.android) === null || _a === void 0 ? void 0 : _a.flavorDimensions) !== null && _b !== void 0 ? _b : '').split(',').length > 1;
    if (hasFlavorDimensions) {
        throw new Error('flavorDimensions in build.gradle are not supported yet');
    }
    const flavors = new Set(Object.keys((_d = (_c = buildGradle === null || buildGradle === void 0 ? void 0 : buildGradle.android) === null || _c === void 0 ? void 0 : _c.productFlavors) !== null && _d !== void 0 ? _d : {}));
    // remove any params specified after command name
    const [withoutParams] = cmd.split(' ');
    // remove leading :
    const rawCmd = withoutParams.startsWith(':') ? withoutParams.slice(1) : withoutParams;
    // separate moduleName and rest of the definition
    const splitCmd = rawCmd.split(':');
    const [moduleName, taskName] = splitCmd.length > 1 ? [splitCmd[0], splitCmd[1]] : [undefined, splitCmd[0]];
    const matchResult = taskName.match(/(build|bundle|assemble|package)(.*)(Release|Debug)/);
    if (!matchResult) {
        throw new Error(`Failed to parse gradle command: ${cmd}`);
    }
    let flavor;
    if (matchResult[2]) {
        const [firstLetter, rest] = [matchResult[2].slice(0, 1), matchResult[2].slice(1)];
        // first letter casing is not known based on gradle task name
        // so we need to check both options
        const flavorOptions = [
            firstLetter.toLowerCase().concat(rest),
            firstLetter.toUpperCase().concat(rest),
        ];
        flavorOptions.forEach(option => {
            if (flavors.has(option)) {
                flavor = option;
            }
        });
        if (!flavor) {
            throw new Error(`flavor ${firstLetter.toLowerCase().concat(rest)} is not defined`);
        }
    }
    return {
        moduleName,
        flavor,
        buildType: matchResult[3] ? matchResult[3].toLowerCase() : undefined,
    };
}
exports.parseGradleCommand = parseGradleCommand;
