"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findTargetByName = exports.findApplicationTarget = exports.resolveTargetsAsync = void 0;
const tslib_1 = require("tslib");
const config_plugins_1 = require("@expo/config-plugins");
const eas_build_job_1 = require("@expo/eas-build-job");
const joi_1 = tslib_1.__importDefault(require("joi"));
const workflow_1 = require("../workflow");
const bundleIdentifier_1 = require("./bundleIdentifier");
const AppExtensionsConfigSchema = joi_1.default.array().items(joi_1.default.object({
    targetName: joi_1.default.string().required(),
    bundleIdentifier: joi_1.default.string().required(),
    parentBundleIdentifier: joi_1.default.string(),
}));
async function resolveTargetsAsync({ exp, projectDir }, { buildConfiguration, buildScheme }) {
    const result = [];
    const applicationTarget = await readApplicationTargetForSchemeAsync(projectDir, buildScheme);
    const bundleIdentifier = await (0, bundleIdentifier_1.getBundleIdentifierAsync)(projectDir, exp, {
        targetName: applicationTarget.name,
        buildConfiguration,
    });
    result.push({
        targetName: applicationTarget.name,
        bundleIdentifier,
        buildConfiguration,
    });
    const dependencies = await resolveDependenciesAsync({
        exp,
        projectDir,
        buildConfiguration,
        target: applicationTarget,
        bundleIdentifier,
    });
    if (dependencies.length > 0) {
        result.push(...dependencies);
    }
    result.push(...(await resolveManagedAppExtensionsAsync({
        exp,
        projectDir,
        buildConfiguration,
        applicationTargetBundleIdentifier: bundleIdentifier,
    })));
    return result;
}
exports.resolveTargetsAsync = resolveTargetsAsync;
async function resolveManagedAppExtensionsAsync({ exp, projectDir, buildConfiguration, applicationTargetBundleIdentifier, }) {
    var _a, _b, _c, _d, _e;
    const workflow = await (0, workflow_1.resolveWorkflowAsync)(projectDir, eas_build_job_1.Platform.IOS);
    const managedAppExtensions = (_e = (_d = (_c = (_b = (_a = exp.extra) === null || _a === void 0 ? void 0 : _a.eas) === null || _b === void 0 ? void 0 : _b.build) === null || _c === void 0 ? void 0 : _c.experimental) === null || _d === void 0 ? void 0 : _d.ios) === null || _e === void 0 ? void 0 : _e.appExtensions;
    if (workflow === eas_build_job_1.Workflow.GENERIC || !managedAppExtensions) {
        return [];
    }
    const { error } = AppExtensionsConfigSchema.validate(managedAppExtensions, {
        allowUnknown: false,
        abortEarly: false,
    });
    if (error) {
        throw new Error(`Failed to validate "extra.eas.build.experimental.ios.appExtensions" in you app config\n${error.message}`);
    }
    return managedAppExtensions.map(extension => {
        var _a;
        return ({
            targetName: extension.targetName,
            buildConfiguration,
            bundleIdentifier: extension.bundleIdentifier,
            parentBundleIdentifier: (_a = extension.parentBundleIdentifier) !== null && _a !== void 0 ? _a : applicationTargetBundleIdentifier,
        });
    });
}
async function resolveDependenciesAsync({ exp, projectDir, buildConfiguration, target, bundleIdentifier, }) {
    const result = [];
    if (target.dependencies && target.dependencies.length > 0) {
        for (const dependency of target.dependencies) {
            const dependencyBundleIdentifier = await (0, bundleIdentifier_1.getBundleIdentifierAsync)(projectDir, exp, {
                targetName: dependency.name,
                buildConfiguration,
            });
            result.push({
                targetName: dependency.name,
                buildConfiguration,
                bundleIdentifier: dependencyBundleIdentifier,
                parentBundleIdentifier: bundleIdentifier,
            });
            const dependencyDependencies = await resolveDependenciesAsync({
                exp,
                projectDir,
                buildConfiguration,
                target: dependency,
                bundleIdentifier: dependencyBundleIdentifier,
            });
            if (dependencyDependencies.length > 0) {
                result.push(...dependencyDependencies);
            }
        }
    }
    return result;
}
async function readApplicationTargetForSchemeAsync(projectDir, scheme) {
    const workflow = await (0, workflow_1.resolveWorkflowAsync)(projectDir, eas_build_job_1.Platform.IOS);
    if (workflow === eas_build_job_1.Workflow.GENERIC) {
        return await config_plugins_1.IOSConfig.Target.findApplicationTargetWithDependenciesAsync(projectDir, scheme);
    }
    else {
        return {
            name: scheme,
            type: config_plugins_1.IOSConfig.Target.TargetType.APPLICATION,
            dependencies: [],
        };
    }
}
function findApplicationTarget(targets) {
    const applicationTarget = targets.find(({ parentBundleIdentifier }) => !parentBundleIdentifier);
    if (!applicationTarget) {
        throw new Error('Could not find the application target');
    }
    return applicationTarget;
}
exports.findApplicationTarget = findApplicationTarget;
function findTargetByName(targets, name) {
    const target = targets.find(target => target.targetName === name);
    if (!target) {
        throw new Error(`Could not find target '${name}'`);
    }
    return target;
}
exports.findTargetByName = findTargetByName;
