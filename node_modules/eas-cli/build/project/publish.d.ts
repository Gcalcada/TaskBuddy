/// <reference types="node" />
import { ExpoConfig, Platform } from '@expo/config';
import Joi from 'joi';
import { PartialManifestAsset } from '../graphql/generated';
export declare const TIMEOUT_LIMIT = 60000;
export declare type PublishPlatform = Extract<'android' | 'ios', Platform>;
declare type Metadata = {
    version: number;
    bundler: 'metro';
    fileMetadata: {
        [key in 'android' | 'ios']: {
            assets: {
                path: string;
                ext: string;
            }[];
            bundle: string;
        };
    };
};
export declare type RawAsset = {
    fileExtension?: string;
    contentType: string;
    path: string;
};
declare type CollectedAssets = {
    [platform in PublishPlatform]?: {
        launchAsset: RawAsset;
        assets: RawAsset[];
    };
};
declare type ManifestExtra = {
    expoClient?: {
        [key: string]: any;
    };
    [key: string]: any;
};
declare type ManifestFragment = {
    launchAsset: PartialManifestAsset;
    assets: PartialManifestAsset[];
    extra?: ManifestExtra;
};
declare type UpdateInfoGroup = {
    [key in PublishPlatform]: ManifestFragment;
};
export declare const MetadataJoi: Joi.ObjectSchema<any>;
export declare function guessContentTypeFromExtension(ext?: string): string;
export declare function getBase64URLEncoding(buffer: Buffer): string;
/**
 * The storage key is used to store the asset in GCS
 */
export declare function getStorageKey(contentType: string, contentHash: string): string;
/**
 * Convenience function that computes an assets storage key starting from its buffer.
 */
export declare function getStorageKeyForAssetAsync(asset: RawAsset): Promise<string>;
export declare function convertAssetToUpdateInfoGroupFormatAsync(asset: RawAsset): Promise<PartialManifestAsset>;
/**
 * This will be sorted later based on the platform's runtime versions.
 */
export declare function buildUnsortedUpdateInfoGroupAsync(assets: CollectedAssets, exp: ExpoConfig): Promise<UpdateInfoGroup>;
export declare function buildBundlesAsync({ projectDir, inputDir, }: {
    projectDir: string;
    inputDir: string;
}): Promise<void>;
export declare function resolveInputDirectoryAsync(customInputDirectory: string): Promise<string>;
export declare function loadMetadata(distRoot: string): Metadata;
export declare function collectAssetsAsync({ inputDir, platforms, }: {
    inputDir: string;
    platforms: PublishPlatform[];
}): Promise<CollectedAssets>;
export declare function filterOutAssetsThatAlreadyExistAsync(uniqueAssetsWithStorageKey: (RawAsset & {
    storageKey: string;
})[]): Promise<(RawAsset & {
    storageKey: string;
})[]>;
export declare function uploadAssetsAsync(assetsForUpdateInfoGroup: CollectedAssets): Promise<void>;
export {};
