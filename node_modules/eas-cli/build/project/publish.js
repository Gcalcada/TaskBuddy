"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uploadAssetsAsync = exports.filterOutAssetsThatAlreadyExistAsync = exports.collectAssetsAsync = exports.loadMetadata = exports.resolveInputDirectoryAsync = exports.buildBundlesAsync = exports.buildUnsortedUpdateInfoGroupAsync = exports.convertAssetToUpdateInfoGroupFormatAsync = exports.getStorageKeyForAssetAsync = exports.getStorageKey = exports.getBase64URLEncoding = exports.guessContentTypeFromExtension = exports.MetadataJoi = exports.TIMEOUT_LIMIT = void 0;
const tslib_1 = require("tslib");
const json_file_1 = tslib_1.__importDefault(require("@expo/json-file"));
const crypto_1 = tslib_1.__importDefault(require("crypto"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const joi_1 = tslib_1.__importDefault(require("joi"));
const mime_1 = tslib_1.__importDefault(require("mime"));
const path_1 = tslib_1.__importDefault(require("path"));
const generated_1 = require("../graphql/generated");
const PublishMutation_1 = require("../graphql/mutations/PublishMutation");
const PublishQuery_1 = require("../graphql/queries/PublishQuery");
const uploads_1 = require("../uploads");
const expoCli_1 = require("../utils/expoCli");
const uniqBy_1 = tslib_1.__importDefault(require("../utils/expodash/uniqBy"));
exports.TIMEOUT_LIMIT = 60000; // 1 minute
const fileMetadataJoi = joi_1.default.object({
    assets: joi_1.default.array()
        .required()
        .items(joi_1.default.object({ path: joi_1.default.string().required(), ext: joi_1.default.string().required() })),
    bundle: joi_1.default.string().required(),
}).required();
exports.MetadataJoi = joi_1.default.object({
    version: joi_1.default.number().required(),
    bundler: joi_1.default.string().required(),
    fileMetadata: joi_1.default.object({
        android: fileMetadataJoi,
        ios: fileMetadataJoi,
    }).required(),
}).required();
function guessContentTypeFromExtension(ext) {
    var _a;
    return (_a = mime_1.default.getType(ext !== null && ext !== void 0 ? ext : '')) !== null && _a !== void 0 ? _a : 'application/octet-stream'; // unrecognized extension
}
exports.guessContentTypeFromExtension = guessContentTypeFromExtension;
function getBase64URLEncoding(buffer) {
    const base64 = buffer.toString('base64');
    return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}
exports.getBase64URLEncoding = getBase64URLEncoding;
/**
 * The storage key is used to store the asset in GCS
 */
function getStorageKey(contentType, contentHash) {
    const nullSeparator = Buffer.alloc(1);
    const hash = crypto_1.default
        .createHash('sha256')
        .update(contentType)
        .update(nullSeparator)
        .update(contentHash)
        .digest();
    return getBase64URLEncoding(hash);
}
exports.getStorageKey = getStorageKey;
async function calculateFileHashAsync(filePath, algorithm) {
    return new Promise((resolve, reject) => {
        const file = fs_extra_1.default.createReadStream(filePath).on('error', reject);
        const hash = file.pipe(crypto_1.default.createHash(algorithm)).on('error', reject);
        hash.on('finish', () => resolve(hash.read()));
    });
}
/**
 * Convenience function that computes an assets storage key starting from its buffer.
 */
async function getStorageKeyForAssetAsync(asset) {
    const fileSHA256 = getBase64URLEncoding(await calculateFileHashAsync(asset.path, 'sha256'));
    return getStorageKey(asset.contentType, fileSHA256);
}
exports.getStorageKeyForAssetAsync = getStorageKeyForAssetAsync;
async function convertAssetToUpdateInfoGroupFormatAsync(asset) {
    const fileSHA256 = getBase64URLEncoding(await calculateFileHashAsync(asset.path, 'sha256'));
    const { contentType, fileExtension } = asset;
    const storageKey = getStorageKey(contentType, fileSHA256);
    const bundleKey = (await calculateFileHashAsync(asset.path, 'md5')).toString('hex');
    return {
        fileSHA256,
        contentType,
        storageKey,
        bundleKey,
        fileExtension,
    };
}
exports.convertAssetToUpdateInfoGroupFormatAsync = convertAssetToUpdateInfoGroupFormatAsync;
/**
 * This will be sorted later based on the platform's runtime versions.
 */
async function buildUnsortedUpdateInfoGroupAsync(assets, exp) {
    var _a, _b, _c;
    let platform;
    const updateInfoGroup = {};
    for (platform in assets) {
        updateInfoGroup[platform] = {
            launchAsset: await convertAssetToUpdateInfoGroupFormatAsync((_a = assets[platform]) === null || _a === void 0 ? void 0 : _a.launchAsset),
            assets: await Promise.all(((_c = (_b = assets[platform]) === null || _b === void 0 ? void 0 : _b.assets) !== null && _c !== void 0 ? _c : []).map(convertAssetToUpdateInfoGroupFormatAsync)),
            extra: {
                expoClient: exp,
            },
        };
    }
    return updateInfoGroup;
}
exports.buildUnsortedUpdateInfoGroupAsync = buildUnsortedUpdateInfoGroupAsync;
async function buildBundlesAsync({ projectDir, inputDir, }) {
    const packageJSON = json_file_1.default.read(path_1.default.resolve(projectDir, 'package.json'));
    if (!packageJSON) {
        throw new Error('Could not locate package.json');
    }
    await (0, expoCli_1.expoCommandAsync)(projectDir, ['export', '--output-dir', inputDir, '--experimental-bundle'], { silent: true });
}
exports.buildBundlesAsync = buildBundlesAsync;
async function resolveInputDirectoryAsync(customInputDirectory) {
    const distRoot = path_1.default.resolve(customInputDirectory);
    if (!(await fs_extra_1.default.pathExists(distRoot))) {
        throw new Error(`The input directory "${customInputDirectory}" does not exist.
    You can allow us to build it for you by not setting the --skip-bundler flag.
    If you chose to build it yourself you'll need to run a command to build the JS
    bundle first.
    You can use '--input-dir' to specify a different input directory.`);
    }
    return distRoot;
}
exports.resolveInputDirectoryAsync = resolveInputDirectoryAsync;
function loadMetadata(distRoot) {
    const metadata = json_file_1.default.read(path_1.default.join(distRoot, 'metadata.json'));
    const { error } = exports.MetadataJoi.validate(metadata);
    if (error) {
        throw error;
    }
    // Check version and bundler by hand (instead of with Joi) so
    // more informative error messages can be returned.
    if (metadata.version !== 0) {
        throw new Error('Only bundles with metadata version 0 are supported');
    }
    if (metadata.bundler !== 'metro') {
        throw new Error('Only bundles created with Metro are currently supported');
    }
    return metadata;
}
exports.loadMetadata = loadMetadata;
async function collectAssetsAsync({ inputDir, platforms, }) {
    const distRoot = await resolveInputDirectoryAsync(inputDir);
    const metadata = loadMetadata(distRoot);
    const assetsFinal = {};
    for (const platform of platforms) {
        assetsFinal[platform] = {
            launchAsset: {
                fileExtension: '.bundle',
                contentType: 'application/javascript',
                path: path_1.default.resolve(distRoot, metadata.fileMetadata[platform].bundle),
            },
            assets: metadata.fileMetadata[platform].assets.map(asset => {
                let fileExtension;
                if (asset.ext) {
                    // ensure the file extension has a '.' prefix
                    fileExtension = asset.ext.startsWith('.') ? asset.ext : `.${asset.ext}`;
                }
                return {
                    fileExtension,
                    contentType: guessContentTypeFromExtension(asset.ext),
                    path: path_1.default.join(distRoot, asset.path),
                };
            }),
        };
    }
    return assetsFinal;
}
exports.collectAssetsAsync = collectAssetsAsync;
async function filterOutAssetsThatAlreadyExistAsync(uniqueAssetsWithStorageKey) {
    const assetMetadata = await PublishQuery_1.PublishQuery.getAssetMetadataAsync(uniqueAssetsWithStorageKey.map(asset => asset.storageKey));
    const missingAssetKeys = assetMetadata
        .filter(result => result.status !== generated_1.AssetMetadataStatus.Exists)
        .map(result => result.storageKey);
    const missingAssets = uniqueAssetsWithStorageKey.filter(asset => {
        return missingAssetKeys.includes(asset.storageKey);
    });
    return missingAssets;
}
exports.filterOutAssetsThatAlreadyExistAsync = filterOutAssetsThatAlreadyExistAsync;
async function uploadAssetsAsync(assetsForUpdateInfoGroup) {
    let assets = [];
    let platform;
    for (platform in assetsForUpdateInfoGroup) {
        assets = [
            ...assets,
            assetsForUpdateInfoGroup[platform].launchAsset,
            ...assetsForUpdateInfoGroup[platform].assets,
        ];
    }
    const assetsWithStorageKey = await Promise.all(assets.map(async (asset) => {
        return {
            ...asset,
            storageKey: await getStorageKeyForAssetAsync(asset),
        };
    }));
    const uniqueAssets = (0, uniqBy_1.default)(assetsWithStorageKey, asset => asset.storageKey);
    let missingAssets = await filterOutAssetsThatAlreadyExistAsync(uniqueAssets);
    const { specifications } = await PublishMutation_1.PublishMutation.getUploadURLsAsync(missingAssets.map(ma => ma.contentType));
    await Promise.all(missingAssets.map((missingAsset, i) => {
        const presignedPost = JSON.parse(specifications[i]);
        return (0, uploads_1.uploadWithPresignedPostAsync)(missingAsset.path, presignedPost);
    }));
    // Wait up to TIMEOUT_LIMIT for assets to be uploaded and processed
    const start = Date.now();
    let timeout = 1;
    while (missingAssets.length > 0) {
        const timeoutPromise = new Promise(resolve => setTimeout(resolve, timeout * 1000)); // linear backoff
        missingAssets = await filterOutAssetsThatAlreadyExistAsync(missingAssets);
        await timeoutPromise; // await after filterOutAssetsThatAlreadyExistAsync for easy mocking with jest.runAllTimers
        timeout += 1;
        if (Date.now() - start > exports.TIMEOUT_LIMIT) {
            throw new Error('Asset upload timed out. Please try again.');
        }
    }
}
exports.uploadAssetsAsync = uploadAssetsAsync;
