"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerNewProjectAsync = exports.findProjectIdByAccountNameAndSlugNullableAsync = exports.ensureProjectExistsAsync = void 0;
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const terminal_link_1 = tslib_1.__importDefault(require("terminal-link"));
const url_1 = require("../build/utils/url");
const generated_1 = require("../graphql/generated");
const AppMutation_1 = require("../graphql/mutations/AppMutation");
const ProjectQuery_1 = require("../graphql/queries/ProjectQuery");
const ora_1 = require("../ora");
const Account_1 = require("../user/Account");
const actions_1 = require("../user/actions");
const projectCache = {};
/**
 * Ensures project exists on EAS servers. Registers it when it doesn't
 * @returns The project ID
 */
async function ensureProjectExistsAsync(projectInfo) {
    const { accountName, projectName } = projectInfo;
    const projectFullName = `@${accountName}/${projectName}`;
    if (projectFullName in projectCache) {
        return projectCache[projectFullName];
    }
    const actor = await (0, actions_1.ensureLoggedInAsync)();
    const account = (0, Account_1.findAccountByName)(actor.accounts, accountName);
    (0, assert_1.default)(account, `You must have access to the ${accountName} account to run this command`);
    const projectDashboardUrl = (0, url_1.getProjectDashboardUrl)(accountName, projectName);
    const projectLink = (0, terminal_link_1.default)(projectFullName, projectDashboardUrl);
    const spinner = (0, ora_1.ora)(`Linking to project ${chalk_1.default.bold(projectFullName)}`).start();
    const maybeId = await findProjectIdByAccountNameAndSlugNullableAsync(accountName, projectName);
    if (maybeId) {
        spinner.succeed(`Linked to project ${chalk_1.default.bold(projectLink)}`);
        projectCache[projectFullName] = maybeId;
        return maybeId;
    }
    try {
        spinner.text = `Creating ${chalk_1.default.bold(projectFullName)} on Expo`;
        const id = await registerNewProjectAsync({
            accountId: account.id,
            projectName,
            privacy: projectInfo.privacy,
        });
        spinner.succeed(`Created ${chalk_1.default.bold(projectLink)} on Expo`);
        projectCache[projectFullName] = id;
        return id;
    }
    catch (err) {
        spinner.fail();
        throw err;
    }
}
exports.ensureProjectExistsAsync = ensureProjectExistsAsync;
/**
 * Finds project by `@accountName/slug` and returns its ID, return null if the project does not exist
 * @param accountName account name
 * @param slug project slug
 * @returns A promise resolving to Project ID, null if it doesn't exist
 */
async function findProjectIdByAccountNameAndSlugNullableAsync(accountName, slug) {
    var _a;
    try {
        return await findProjectIdByAccountNameAndSlugAsync(accountName, slug);
    }
    catch (err) {
        if ((_a = err.graphQLErrors) === null || _a === void 0 ? void 0 : _a.some((it) => { var _a; return ((_a = it.extensions) === null || _a === void 0 ? void 0 : _a.errorCode) !== 'EXPERIENCE_NOT_FOUND'; })) {
            throw err;
        }
        return null;
    }
}
exports.findProjectIdByAccountNameAndSlugNullableAsync = findProjectIdByAccountNameAndSlugNullableAsync;
/**
 * Finds project by `@accountName/slug` and returns its ID
 * @param accountName account name
 * @param slug project slug
 * @returns A promise resolving to Project ID
 */
async function findProjectIdByAccountNameAndSlugAsync(accountName, slug) {
    const { id } = await ProjectQuery_1.ProjectQuery.byUsernameAndSlugAsync(accountName, slug);
    return id;
}
/**
 * Registers new project on EAS servers
 * @returns Created project's ID
 */
async function registerNewProjectAsync({ accountId, projectName, privacy, }) {
    return AppMutation_1.AppMutation.createAppAsync({
        accountId,
        projectName,
        privacy: privacy !== null && privacy !== void 0 ? privacy : generated_1.AppPrivacy.Public,
    });
}
exports.registerNewProjectAsync = registerNewProjectAsync;
