"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.retryUsernamePasswordAuthWithOTPAsync = exports.UserSecondFactorDeviceMethod = void 0;
const tslib_1 = require("tslib");
const assert_1 = tslib_1.__importDefault(require("assert"));
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const api_1 = require("../api");
const log_1 = tslib_1.__importDefault(require("../log"));
const prompts_1 = require("../prompts");
const User_1 = require("./User");
var UserSecondFactorDeviceMethod;
(function (UserSecondFactorDeviceMethod) {
    UserSecondFactorDeviceMethod["AUTHENTICATOR"] = "authenticator";
    UserSecondFactorDeviceMethod["SMS"] = "sms";
})(UserSecondFactorDeviceMethod = exports.UserSecondFactorDeviceMethod || (exports.UserSecondFactorDeviceMethod = {}));
/**
 * Prompt for an OTP with the option to cancel the question by answering empty (pressing return key).
 */
async function promptForOTPAsync(cancelBehavior) {
    const enterMessage = cancelBehavior === 'cancel'
        ? `press ${chalk_1.default.bold('Enter')} to cancel`
        : `press ${chalk_1.default.bold('Enter')} for more options`;
    const { otp } = await (0, prompts_1.promptAsync)({
        type: 'text',
        name: 'otp',
        message: `One-time password or backup code (${enterMessage}):`,
    });
    if (!otp) {
        return null;
    }
    return otp;
}
/**
 * Prompt for user to choose a backup OTP method. If selected method is SMS, a request
 * for a new OTP will be sent to that method. Then, prompt for the OTP, and retry the user login.
 */
async function promptForBackupOTPAsync(username, password, secondFactorDevices) {
    const nonPrimarySecondFactorDevices = secondFactorDevices.filter(device => !device.is_primary);
    if (nonPrimarySecondFactorDevices.length === 0) {
        throw new Error('No other second-factor devices set up. Ensure you have set up and certified a backup device.');
    }
    const hasAuthenticatorSecondFactorDevice = nonPrimarySecondFactorDevices.find(device => device.method === UserSecondFactorDeviceMethod.AUTHENTICATOR);
    const smsNonPrimarySecondFactorDevices = nonPrimarySecondFactorDevices.filter(device => device.method === UserSecondFactorDeviceMethod.SMS);
    const authenticatorChoiceSentinel = -1;
    const cancelChoiceSentinel = -2;
    const deviceChoices = smsNonPrimarySecondFactorDevices.map((device, idx) => ({
        title: device.sms_phone_number,
        value: idx,
    }));
    if (hasAuthenticatorSecondFactorDevice) {
        deviceChoices.push({
            title: 'Authenticator',
            value: authenticatorChoiceSentinel,
        });
    }
    deviceChoices.push({
        title: 'Cancel',
        value: cancelChoiceSentinel,
    });
    const selectedValue = await (0, prompts_1.selectAsync)('Select a second-factor device:', deviceChoices);
    if (selectedValue === cancelChoiceSentinel) {
        return null;
    }
    else if (selectedValue === authenticatorChoiceSentinel) {
        return await promptForOTPAsync('cancel');
    }
    const device = smsNonPrimarySecondFactorDevices[selectedValue];
    await api_1.api.postAsync('auth/send-sms-otp', {
        body: {
            username,
            password,
            secondFactorDeviceID: device.id,
        },
    });
    return await promptForOTPAsync('cancel');
}
/**
 * Handle the special case error indicating that a second-factor is required for
 * authentication.
 *
 * There are three cases we need to handle:
 * 1. User's primary second-factor device was SMS, OTP was automatically sent by the server to that
 *    device already. In this case we should just prompt for the SMS OTP (or backup code), which the
 *    user should be receiving shortly. We should give the user a way to cancel and the prompt and move
 *    to case 3 below.
 * 2. User's primary second-factor device is authenticator. In this case we should prompt for authenticator
 *    OTP (or backup code) and also give the user a way to cancel and move to case 3 below.
 * 3. User doesn't have a primary device or doesn't have access to their primary device. In this case
 *    we should show a picker of the SMS devices that they can have an OTP code sent to, and when
 *    the user picks one we show a prompt() for the sent OTP.
 */
async function retryUsernamePasswordAuthWithOTPAsync(username, password, metadata) {
    const { secondFactorDevices, smsAutomaticallySent } = metadata;
    (0, assert_1.default)(secondFactorDevices !== undefined && smsAutomaticallySent !== undefined, `Malformed OTP error metadata: ${metadata}`);
    const primaryDevice = secondFactorDevices.find(device => device.is_primary);
    let otp = null;
    if (smsAutomaticallySent) {
        (0, assert_1.default)(primaryDevice, 'OTP should only automatically be sent when there is a primary device');
        log_1.default.log(`One-time password was sent to the phone number ending in ${primaryDevice.sms_phone_number}.`);
        otp = await promptForOTPAsync('menu');
    }
    if ((primaryDevice === null || primaryDevice === void 0 ? void 0 : primaryDevice.method) === UserSecondFactorDeviceMethod.AUTHENTICATOR) {
        log_1.default.log('One-time password from authenticator required.');
        otp = await promptForOTPAsync('menu');
    }
    // user bailed on case 1 or 2, wants to move to case 3
    if (!otp) {
        otp = await promptForBackupOTPAsync(username, password, secondFactorDevices);
    }
    if (!otp) {
        throw new Error('Cancelled login');
    }
    await (0, User_1.loginAsync)({
        username,
        password,
        otp,
    });
}
exports.retryUsernamePasswordAuthWithOTPAsync = retryUsernamePasswordAuthWithOTPAsync;
