"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.evaluateTemplateString = exports.getInfoPlistPath = exports.maybeResolveVersionsAsync = exports.readBuildNumberAsync = exports.readShortVersionAsync = exports.bumpVersionInAppJsonAsync = exports.bumpVersionAsync = exports.BumpStrategy = void 0;
const tslib_1 = require("tslib");
const config_1 = require("@expo/config");
const config_plugins_1 = require("@expo/config-plugins");
const eas_build_job_1 = require("@expo/eas-build-job");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const path_1 = tslib_1.__importDefault(require("path"));
const log_1 = tslib_1.__importDefault(require("../../log"));
const workflow_1 = require("../../project/workflow");
const prompts_1 = require("../../prompts");
const plist_1 = require("../../utils/plist");
const appJson_1 = require("../utils/appJson");
const version_1 = require("../utils/version");
var BumpStrategy;
(function (BumpStrategy) {
    BumpStrategy[BumpStrategy["APP_VERSION"] = 0] = "APP_VERSION";
    BumpStrategy[BumpStrategy["BUILD_NUMBER"] = 1] = "BUILD_NUMBER";
    BumpStrategy[BumpStrategy["NOOP"] = 2] = "NOOP";
})(BumpStrategy = exports.BumpStrategy || (exports.BumpStrategy = {}));
async function bumpVersionAsync({ bumpStrategy, projectDir, exp, buildSettings, }) {
    if (bumpStrategy === BumpStrategy.NOOP) {
        return;
    }
    ensureStaticConfigExists(projectDir);
    const infoPlist = await readInfoPlistAsync(projectDir, buildSettings);
    await bumpVersionInAppJsonAsync({ bumpStrategy, projectDir, exp });
    log_1.default.log('Updated versions in app.json');
    await writeVersionsToInfoPlistAsync({ projectDir, exp, infoPlist, buildSettings });
    log_1.default.log('Synchronized versions with Info.plist');
}
exports.bumpVersionAsync = bumpVersionAsync;
async function bumpVersionInAppJsonAsync({ bumpStrategy, projectDir, exp, }) {
    if (bumpStrategy === BumpStrategy.NOOP) {
        return;
    }
    ensureStaticConfigExists(projectDir);
    log_1.default.addNewLineIfNone();
    if (bumpStrategy === BumpStrategy.APP_VERSION) {
        const appVersion = config_plugins_1.IOSConfig.Version.getVersion(exp);
        await (0, version_1.bumpAppVersionAsync)({ appVersion, projectDir, exp });
    }
    else {
        const buildNumber = config_plugins_1.IOSConfig.Version.getBuildNumber(exp);
        if (buildNumber.match(/^\d+(\.\d+)*$/)) {
            const comps = buildNumber.split('.');
            comps[comps.length - 1] = String(Number(comps[comps.length - 1]) + 1);
            const bumpedBuildNumber = comps.join('.');
            log_1.default.log(`Bumping ${chalk_1.default.bold('expo.ios.buildNumber')} from ${chalk_1.default.bold(buildNumber)} to ${chalk_1.default.bold(bumpedBuildNumber)}`);
            await (0, appJson_1.updateAppJsonConfigAsync)({ projectDir, exp }, config => {
                config.ios = { ...config.ios, buildNumber: String(bumpedBuildNumber) };
            });
        }
        else {
            log_1.default.log(`${chalk_1.default.bold('expo.ios.buildNumber')} = ${chalk_1.default.bold(buildNumber)} is not a number`);
            const { bumpedBuildNumber } = await (0, prompts_1.promptAsync)({
                type: 'text',
                name: 'bumpedBuildNumber',
                message: 'What is the next build number?',
            });
            await (0, appJson_1.updateAppJsonConfigAsync)({ projectDir, exp }, config => {
                config.ios = { ...config.ios, buildNumber: String(bumpedBuildNumber) };
            });
        }
    }
}
exports.bumpVersionInAppJsonAsync = bumpVersionInAppJsonAsync;
async function readShortVersionAsync(projectDir, exp, buildSettings) {
    const workflow = await (0, workflow_1.resolveWorkflowAsync)(projectDir, eas_build_job_1.Platform.IOS);
    if (workflow === eas_build_job_1.Workflow.GENERIC) {
        const infoPlist = await readInfoPlistAsync(projectDir, buildSettings);
        return (infoPlist.CFBundleShortVersionString &&
            evaluateTemplateString(infoPlist.CFBundleShortVersionString, buildSettings));
    }
    else {
        return exp.version;
    }
}
exports.readShortVersionAsync = readShortVersionAsync;
async function readBuildNumberAsync(projectDir, exp, buildSettings) {
    const workflow = await (0, workflow_1.resolveWorkflowAsync)(projectDir, eas_build_job_1.Platform.IOS);
    if (workflow === eas_build_job_1.Workflow.GENERIC) {
        const infoPlist = await readInfoPlistAsync(projectDir, buildSettings);
        return (infoPlist.CFBundleVersion && evaluateTemplateString(infoPlist.CFBundleVersion, buildSettings));
    }
    else {
        return config_plugins_1.IOSConfig.Version.getBuildNumber(exp);
    }
}
exports.readBuildNumberAsync = readBuildNumberAsync;
async function maybeResolveVersionsAsync(projectDir, exp, buildSettings) {
    try {
        return {
            appBuildVersion: await readBuildNumberAsync(projectDir, exp, buildSettings),
            appVersion: await readShortVersionAsync(projectDir, exp, buildSettings),
        };
    }
    catch (err) {
        log_1.default.warn('Failed to read app versions.');
        log_1.default.debug(err);
        log_1.default.warn(err.message);
        log_1.default.warn('Proceeding anyway...');
        return {};
    }
}
exports.maybeResolveVersionsAsync = maybeResolveVersionsAsync;
async function writeVersionsToInfoPlistAsync({ projectDir, exp, infoPlist, buildSettings, }) {
    let updatedInfoPlist = config_plugins_1.IOSConfig.Version.setVersion(exp, infoPlist);
    updatedInfoPlist = config_plugins_1.IOSConfig.Version.setBuildNumber(exp, updatedInfoPlist);
    await writeInfoPlistAsync({ projectDir, infoPlist: updatedInfoPlist, buildSettings });
    return updatedInfoPlist;
}
function getInfoPlistPath(projectDir, buildSettings) {
    if (buildSettings.INFOPLIST_FILE) {
        const infoPlistFile = buildSettings.INFOPLIST_FILE.startsWith('"')
            ? buildSettings.INFOPLIST_FILE.slice(1, -1)
            : buildSettings.INFOPLIST_FILE;
        const iosDir = path_1.default.join(projectDir, 'ios');
        const plistPath = evaluateTemplateString(infoPlistFile, {
            ...buildSettings,
            SRCROOT: iosDir,
        });
        return path_1.default.isAbsolute(plistPath) ? plistPath : path_1.default.resolve(iosDir, plistPath);
    }
    else {
        return config_plugins_1.IOSConfig.Paths.getInfoPlistPath(projectDir);
    }
}
exports.getInfoPlistPath = getInfoPlistPath;
async function readInfoPlistAsync(projectDir, buildSettings) {
    var _a;
    const infoPlistPath = getInfoPlistPath(projectDir, buildSettings);
    return ((_a = (await (0, plist_1.readPlistAsync)(infoPlistPath))) !== null && _a !== void 0 ? _a : {});
}
async function writeInfoPlistAsync({ projectDir, infoPlist, buildSettings, }) {
    const infoPlistPath = getInfoPlistPath(projectDir, buildSettings);
    await (0, plist_1.writePlistAsync)(infoPlistPath, infoPlist);
}
function ensureStaticConfigExists(projectDir) {
    const paths = (0, config_1.getConfigFilePaths)(projectDir);
    if (!paths.staticConfigPath) {
        throw new Error('autoIncrement option is not supported when using app.config.js');
    }
}
function evaluateTemplateString(s, buildSettings) {
    // necessary because XCBuildConfiguration['buildSettings'] is not a plain object
    const vars = { ...buildSettings };
    return s.replace(/\$\((\w+)\)/g, (match, key) => {
        if (vars.hasOwnProperty(key)) {
            const value = String(vars[key]);
            return value.startsWith('"') ? value.slice(1, -1) : value;
        }
        else {
            return match;
        }
    });
}
exports.evaluateTemplateString = evaluateTemplateString;
