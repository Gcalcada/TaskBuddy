"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.runBuildAndSubmitAsync = void 0;
const tslib_1 = require("tslib");
const eas_build_job_1 = require("@expo/eas-build-job");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const nullthrows_1 = tslib_1.__importDefault(require("nullthrows"));
const generated_1 = require("../graphql/generated");
const AppPlatform_1 = require("../graphql/types/AppPlatform");
const log_1 = tslib_1.__importDefault(require("../log"));
const platform_1 = require("../platform");
const expoSdk_1 = require("../project/expoSdk");
const metroConfig_1 = require("../project/metroConfig");
const context_1 = require("../submit/context");
const submit_1 = require("../submit/submit");
const urls_1 = require("../submit/utils/urls");
const json_1 = require("../utils/json");
const profiles_1 = require("../utils/profiles");
const vcs_1 = require("../vcs");
const build_1 = require("./android/build");
const build_2 = require("./build");
const configure_1 = require("./configure");
const createContext_1 = require("./createContext");
const build_3 = require("./ios/build");
const devClient_1 = require("./utils/devClient");
const printBuildInfo_1 = require("./utils/printBuildInfo");
const repository_1 = require("./utils/repository");
let metroConfigValidated = false;
let sdkVersionChecked = false;
async function runBuildAndSubmitAsync(projectDir, flags) {
    var _a;
    await (0, vcs_1.getVcsClient)().ensureRepoExistsAsync();
    await (0, repository_1.ensureRepoIsCleanAsync)(flags.nonInteractive);
    await (0, configure_1.ensureProjectConfiguredAsync)({
        projectDir,
        nonInteractive: flags.nonInteractive,
    });
    const platforms = (0, platform_1.toPlatforms)(flags.requestedPlatform);
    const buildProfiles = await (0, profiles_1.getProfilesAsync)({
        type: 'build',
        projectDir,
        platforms,
        profileName: (_a = flags.profile) !== null && _a !== void 0 ? _a : undefined,
    });
    await (0, devClient_1.ensureExpoDevClientInstalledForDevClientBuildsAsync)({
        projectDir,
        nonInteractive: flags.nonInteractive,
        buildProfiles,
    });
    const startedBuilds = [];
    const buildCtxByPlatform = {};
    for (const buildProfile of buildProfiles) {
        const { build: maybeBuild, buildCtx } = await prepareAndStartBuildAsync({
            projectDir,
            flags,
            moreBuilds: platforms.length > 1,
            buildProfile,
        });
        if (maybeBuild) {
            startedBuilds.push({ build: maybeBuild, buildProfile });
        }
        buildCtxByPlatform[(0, AppPlatform_1.toAppPlatform)(buildProfile.platform)] = buildCtx;
    }
    if (flags.localBuildOptions.enable) {
        return;
    }
    log_1.default.newLine();
    (0, printBuildInfo_1.printLogsUrls)(startedBuilds.map(startedBuild => startedBuild.build));
    log_1.default.newLine();
    const submissions = [];
    if (flags.autoSubmit) {
        const submitProfiles = await (0, profiles_1.getProfilesAsync)({
            projectDir,
            platforms,
            profileName: flags.submitProfile,
            type: 'submit',
        });
        for (const startedBuild of startedBuilds) {
            const submitProfile = (0, nullthrows_1.default)(submitProfiles.find(({ platform }) => (0, AppPlatform_1.toAppPlatform)(platform) === startedBuild.build.platform)).profile;
            const submission = await prepareAndStartSubmissionAsync({
                build: startedBuild.build,
                buildCtx: (0, nullthrows_1.default)(buildCtxByPlatform[startedBuild.build.platform]),
                moreBuilds: startedBuilds.length > 1,
                projectDir,
                buildProfile: startedBuild.buildProfile.profile,
                submitProfile,
                nonInteractive: flags.nonInteractive,
            });
            submissions.push(submission);
        }
        log_1.default.newLine();
        (0, urls_1.printSubmissionDetailsUrls)(submissions);
        log_1.default.newLine();
    }
    if (!flags.wait) {
        if (flags.json) {
            (0, json_1.printJsonOnlyOutput)(startedBuilds.map(buildInfo => buildInfo.build));
        }
        return;
    }
    const builds = await (0, build_2.waitForBuildEndAsync)(startedBuilds.map(({ build }) => build.id));
    (0, printBuildInfo_1.printBuildResults)(builds, flags.json);
    const haveAllBuildsFailedOrCanceled = builds.every(build => (build === null || build === void 0 ? void 0 : build.status) && [generated_1.BuildStatus.Errored, generated_1.BuildStatus.Canceled].includes(build === null || build === void 0 ? void 0 : build.status));
    if (haveAllBuildsFailedOrCanceled || !flags.autoSubmit) {
        exitWithNonZeroCodeIfSomeBuildsFailed(builds);
    }
    else {
        // the following function also exits with non zero code if any of the submissions failed
        await (0, submit_1.waitToCompleteAsync)(submissions);
    }
}
exports.runBuildAndSubmitAsync = runBuildAndSubmitAsync;
async function prepareAndStartBuildAsync({ projectDir, flags, moreBuilds, buildProfile, }) {
    const buildCtx = await (0, createContext_1.createBuildContextAsync)({
        buildProfileName: buildProfile.profileName,
        clearCache: flags.clearCache,
        buildProfile: buildProfile.profile,
        nonInteractive: flags.nonInteractive,
        platform: buildProfile.platform,
        projectDir,
        localBuildOptions: flags.localBuildOptions,
    });
    if (moreBuilds) {
        log_1.default.newLine();
        const appPlatform = (0, AppPlatform_1.toAppPlatform)(buildProfile.platform);
        log_1.default.log(`${platform_1.appPlatformEmojis[appPlatform]} ${chalk_1.default.bold(`${platform_1.appPlatformDisplayNames[appPlatform]} build`)}`);
    }
    if (buildCtx.workflow === eas_build_job_1.Workflow.MANAGED) {
        if (!sdkVersionChecked) {
            await (0, expoSdk_1.checkExpoSdkIsSupportedAsync)(buildCtx);
            sdkVersionChecked = true;
        }
        if (!metroConfigValidated) {
            await (0, metroConfig_1.validateMetroConfigForManagedWorkflowAsync)(buildCtx);
            metroConfigValidated = true;
        }
    }
    const build = await startBuildAsync(buildCtx);
    return {
        build,
        buildCtx,
    };
}
async function startBuildAsync(ctx) {
    let sendBuildRequestAsync;
    if (ctx.platform === eas_build_job_1.Platform.ANDROID) {
        sendBuildRequestAsync = await (0, build_1.prepareAndroidBuildAsync)(ctx);
    }
    else {
        sendBuildRequestAsync = await (0, build_3.prepareIosBuildAsync)(ctx);
    }
    return await sendBuildRequestAsync();
}
async function prepareAndStartSubmissionAsync({ build, buildCtx, moreBuilds, projectDir, buildProfile, submitProfile, nonInteractive, }) {
    var _a, _b, _c;
    const platform = (0, AppPlatform_1.toPlatform)(build.platform);
    const submissionCtx = await (0, context_1.createSubmissionContextAsync)({
        platform,
        projectDir,
        projectId: build.project.id,
        profile: submitProfile,
        archiveFlags: { id: build.id },
        nonInteractive,
        env: buildProfile.env,
        credentialsCtx: buildCtx.credentialsCtx,
        applicationIdentifier: (_b = (_a = buildCtx.android) === null || _a === void 0 ? void 0 : _a.applicationId) !== null && _b !== void 0 ? _b : (_c = buildCtx.ios) === null || _c === void 0 ? void 0 : _c.bundleIdentifier,
    });
    if (moreBuilds) {
        log_1.default.newLine();
        log_1.default.log(`${platform_1.appPlatformEmojis[build.platform]} ${chalk_1.default.bold(`${platform_1.appPlatformDisplayNames[build.platform]} submission`)}`);
    }
    return await (0, submit_1.submitAsync)(submissionCtx);
}
function exitWithNonZeroCodeIfSomeBuildsFailed(maybeBuilds) {
    const failedBuilds = maybeBuilds.filter(i => i).filter(i => i.status === generated_1.BuildStatus.Errored);
    if (failedBuilds.length > 0) {
        process.exit(1);
    }
}
