"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForBuildEndAsync = exports.prepareBuildRequestForPlatformAsync = void 0;
const tslib_1 = require("tslib");
const eas_build_job_1 = require("@expo/eas-build-job");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const common_1 = require("../analytics/common");
const events_1 = require("../analytics/events");
const generated_1 = require("../graphql/generated");
const BuildQuery_1 = require("../graphql/queries/BuildQuery");
const log_1 = tslib_1.__importStar(require("../log"));
const ora_1 = require("../ora");
const platform_1 = require("../platform");
const uploads_1 = require("../uploads");
const files_1 = require("../utils/files");
const progress_1 = require("../utils/progress");
const promise_1 = require("../utils/promise");
const vcs_1 = require("../vcs");
const local_1 = require("./local");
const metadata_1 = require("./metadata");
const printBuildInfo_1 = require("./utils/printBuildInfo");
const repository_1 = require("./utils/repository");
async function prepareBuildRequestForPlatformAsync(builder) {
    const { ctx } = builder;
    const credentialsResult = await (0, common_1.withAnalyticsAsync)(async () => await builder.ensureCredentialsAsync(ctx), {
        attemptEvent: events_1.BuildEvent.GATHER_CREDENTIALS_ATTEMPT,
        successEvent: events_1.BuildEvent.GATHER_CREDENTIALS_SUCCESS,
        failureEvent: events_1.BuildEvent.GATHER_CREDENTIALS_FAIL,
        trackingCtx: ctx.trackingCtx,
    });
    await (0, common_1.withAnalyticsAsync)(async () => await builder.syncProjectConfigurationAsync(ctx), {
        attemptEvent: events_1.BuildEvent.CONFIGURE_PROJECT_ATTEMPT,
        successEvent: events_1.BuildEvent.CONFIGURE_PROJECT_SUCCESS,
        failureEvent: events_1.BuildEvent.CONFIGURE_PROJECT_FAIL,
        trackingCtx: ctx.trackingCtx,
    });
    if (await (0, vcs_1.getVcsClient)().isCommitRequiredAsync()) {
        log_1.default.addNewLineIfNone();
        await (0, repository_1.reviewAndCommitChangesAsync)(`[EAS Build] Run EAS Build for ${platform_1.requestedPlatformDisplayNames[ctx.platform]}`, { nonInteractive: ctx.nonInteractive });
    }
    const projectArchive = ctx.localBuildOptions.enable
        ? {
            type: eas_build_job_1.ArchiveSourceType.PATH,
            path: (await (0, repository_1.makeProjectTarballAsync)()).path,
        }
        : {
            type: eas_build_job_1.ArchiveSourceType.S3,
            bucketKey: await uploadProjectAsync(ctx),
        };
    const metadata = await (0, metadata_1.collectMetadataAsync)(ctx);
    const job = await builder.prepareJobAsync(ctx, {
        projectArchive,
        credentials: credentialsResult === null || credentialsResult === void 0 ? void 0 : credentialsResult.credentials,
    });
    return async () => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        if (ctx.localBuildOptions.enable) {
            await (0, local_1.runLocalBuildAsync)(job, ctx.localBuildOptions);
            return undefined;
        }
        else {
            try {
                return await sendBuildRequestAsync(builder, job, metadata);
            }
            catch (error) {
                if (((_c = (_b = (_a = error === null || error === void 0 ? void 0 : error.graphQLErrors) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.extensions) === null || _c === void 0 ? void 0 : _c.errorCode) === 'TURTLE_DEPRECATED_JOB_FORMAT') {
                    log_1.default.error('EAS Build API has changed, please upgrade to the latest eas-cli version.');
                    throw new Error('Build request failed.');
                }
                else if (((_f = (_e = (_d = error === null || error === void 0 ? void 0 : error.graphQLErrors) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.extensions) === null || _f === void 0 ? void 0 : _f.errorCode) === 'EAS_BUILD_DOWN_FOR_MAINTENANCE') {
                    log_1.default.error('EAS Build is down for maintenance, please try again later. Check https://status.expo.dev/ for updates.');
                    throw new Error('Build request failed.');
                }
                else if (((_j = (_h = (_g = error === null || error === void 0 ? void 0 : error.graphQLErrors) === null || _g === void 0 ? void 0 : _g[0]) === null || _h === void 0 ? void 0 : _h.extensions) === null || _j === void 0 ? void 0 : _j.errorCode) === 'EAS_BUILD_FREE_TIER_DISABLED') {
                    log_1.default.error('EAS Build free tier is temporarily disabled, please try again later. Check https://status.expo.dev/ for updates.');
                    throw new Error('Build request failed.');
                }
                else if (((_m = (_l = (_k = error === null || error === void 0 ? void 0 : error.graphQLErrors) === null || _k === void 0 ? void 0 : _k[0]) === null || _l === void 0 ? void 0 : _l.extensions) === null || _m === void 0 ? void 0 : _m.errorCode) === 'EAS_BUILD_TOO_MANY_PENDING_BUILDS') {
                    log_1.default.error(`You have already reached the maximum number of pending ${platform_1.requestedPlatformDisplayNames[job.platform]} builds for your account. Try again later.`);
                    throw new Error('Build request failed.');
                }
                else if (error === null || error === void 0 ? void 0 : error.graphQLErrors) {
                    log_1.default.error('Build request failed. Make sure you are using the latest eas-cli version. If the problem persists, please report the issue.');
                }
                throw error;
            }
        }
    };
}
exports.prepareBuildRequestForPlatformAsync = prepareBuildRequestForPlatformAsync;
async function uploadProjectAsync(ctx) {
    let projectTarballPath;
    try {
        return await (0, common_1.withAnalyticsAsync)(async () => {
            const projectTarball = await (0, repository_1.makeProjectTarballAsync)();
            projectTarballPath = projectTarball.path;
            const { bucketKey } = await (0, uploads_1.uploadAsync)(generated_1.UploadSessionType.EasBuildProjectSources, projectTarball.path, (0, progress_1.createProgressTracker)({
                total: projectTarball.size,
                message: ratio => `Uploading to EAS Build (${(0, files_1.formatBytes)(projectTarball.size * ratio)} / ${(0, files_1.formatBytes)(projectTarball.size)})`,
                completedMessage: (duration) => `Uploaded to EAS ${chalk_1.default.dim(duration)} ${(0, log_1.learnMore)('https://expo.fyi/eas-build-archive')}`,
            }));
            return bucketKey;
        }, {
            attemptEvent: events_1.BuildEvent.PROJECT_UPLOAD_ATTEMPT,
            successEvent: events_1.BuildEvent.PROJECT_UPLOAD_SUCCESS,
            failureEvent: events_1.BuildEvent.PROJECT_UPLOAD_FAIL,
            trackingCtx: ctx.trackingCtx,
        });
    }
    finally {
        if (projectTarballPath) {
            await fs_extra_1.default.remove(projectTarballPath);
        }
    }
}
async function sendBuildRequestAsync(builder, job, metadata) {
    const { ctx } = builder;
    return await (0, common_1.withAnalyticsAsync)(async () => {
        if (log_1.default.isDebug) {
            log_1.default.log(`Starting ${platform_1.requestedPlatformDisplayNames[job.platform]} build`);
        }
        const { build, deprecationInfo } = await builder.sendBuildRequestAsync(ctx.projectId, job, metadata);
        (0, printBuildInfo_1.printDeprecationWarnings)(deprecationInfo);
        return build;
    }, {
        attemptEvent: events_1.BuildEvent.BUILD_REQUEST_ATTEMPT,
        successEvent: events_1.BuildEvent.BUILD_REQUEST_SUCCESS,
        failureEvent: events_1.BuildEvent.BUILD_REQUEST_FAIL,
        trackingCtx: ctx.trackingCtx,
    });
}
async function waitForBuildEndAsync(buildIds, { timeoutSec = 3600, intervalSec = 30 } = {}) {
    log_1.default.log(`Waiting for build${buildIds.length > 1 ? 's' : ''} to complete. You can press Ctrl+C to exit.`);
    const spinner = (0, ora_1.ora)().start();
    let time = new Date().getTime();
    const endTime = time + timeoutSec * 1000;
    while (time <= endTime) {
        const builds = await Promise.all(buildIds.map(async (buildId) => {
            try {
                return await BuildQuery_1.BuildQuery.byIdAsync(buildId, { useCache: false });
            }
            catch (err) {
                log_1.default.debug('Failed to fetch the build status', err);
                return null;
            }
        }));
        if (builds.length === 1) {
            const [build] = builds;
            if (build !== null) {
                switch (build.status) {
                    case generated_1.BuildStatus.Finished:
                        spinner.succeed('Build finished');
                        return builds;
                    case generated_1.BuildStatus.New:
                        spinner.text = 'Build created';
                        break;
                    case generated_1.BuildStatus.InQueue:
                        spinner.text = 'Build queued...';
                        break;
                    case generated_1.BuildStatus.Canceled:
                        spinner.text = 'Build canceled';
                        spinner.stopAndPersist();
                        return builds;
                    case generated_1.BuildStatus.InProgress:
                        spinner.text = 'Build in progress...';
                        break;
                    case generated_1.BuildStatus.Errored:
                        spinner.fail('Build failed');
                        if (build.error) {
                            return builds;
                        }
                        else {
                            throw new Error(`Standalone build failed!`);
                        }
                    default:
                        spinner.warn('Unknown status');
                        throw new Error(`Unknown build status: ${build.status} - aborting!`);
                }
            }
            else {
                if (!spinner.text) {
                    spinner.text = 'Could not fetch the build status. Check your network connection.';
                }
            }
        }
        else {
            if (builds.filter(build => (build === null || build === void 0 ? void 0 : build.status) === generated_1.BuildStatus.Finished).length === builds.length) {
                spinner.succeed('All builds have finished');
                return builds;
            }
            else if (builds.filter(build => (build === null || build === void 0 ? void 0 : build.status)
                ? [generated_1.BuildStatus.Finished, generated_1.BuildStatus.Errored, generated_1.BuildStatus.Canceled].includes(build.status)
                : false).length === builds.length) {
                spinner.fail('Some of the builds were canceled or failed.');
                return builds;
            }
            else {
                const newBuilds = builds.filter(build => (build === null || build === void 0 ? void 0 : build.status) === generated_1.BuildStatus.New).length;
                const inQueue = builds.filter(build => (build === null || build === void 0 ? void 0 : build.status) === generated_1.BuildStatus.InQueue).length;
                const inProgress = builds.filter(build => (build === null || build === void 0 ? void 0 : build.status) === generated_1.BuildStatus.InProgress).length;
                const errored = builds.filter(build => (build === null || build === void 0 ? void 0 : build.status) === generated_1.BuildStatus.Errored).length;
                const finished = builds.filter(build => (build === null || build === void 0 ? void 0 : build.status) === generated_1.BuildStatus.Finished).length;
                const canceled = builds.filter(build => (build === null || build === void 0 ? void 0 : build.status) === generated_1.BuildStatus.Canceled).length;
                const unknown = builds.length - newBuilds - inQueue - inProgress - errored - finished - canceled;
                spinner.text = [
                    newBuilds && `Builds created: ${newBuilds}`,
                    inQueue && `Builds in queue: ${inQueue}`,
                    inProgress && `Builds in progress: ${inProgress}`,
                    canceled && `Builds canceled: ${canceled}`,
                    errored && chalk_1.default.red(`Builds failed: ${errored}`),
                    finished && chalk_1.default.green(`Builds finished: ${finished}`),
                    unknown && chalk_1.default.red(`Builds with unknown status: ${unknown}`),
                ]
                    .filter(i => i)
                    .join('\t');
            }
        }
        time = new Date().getTime();
        await (0, promise_1.sleepAsync)(intervalSec * 1000);
    }
    spinner.warn('Timed out');
    throw new Error('Timeout reached! It is taking longer than expected to finish the build, aborting...');
}
exports.waitForBuildEndAsync = waitForBuildEndAsync;
