"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.maybeResolveVersionsAsync = exports.bumpVersionInAppJsonAsync = exports.bumpVersionAsync = exports.BumpStrategy = void 0;
const tslib_1 = require("tslib");
const config_plugins_1 = require("@expo/config-plugins");
const eas_build_job_1 = require("@expo/eas-build-job");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const log_1 = tslib_1.__importDefault(require("../../log"));
const gradleUtils_1 = require("../../project/android/gradleUtils");
const workflow_1 = require("../../project/workflow");
const appJson_1 = require("../utils/appJson");
const version_1 = require("../utils/version");
var BumpStrategy;
(function (BumpStrategy) {
    BumpStrategy[BumpStrategy["APP_VERSION"] = 0] = "APP_VERSION";
    BumpStrategy[BumpStrategy["VERSION_CODE"] = 1] = "VERSION_CODE";
    BumpStrategy[BumpStrategy["NOOP"] = 2] = "NOOP";
})(BumpStrategy = exports.BumpStrategy || (exports.BumpStrategy = {}));
async function bumpVersionAsync({ bumpStrategy, projectDir, exp, }) {
    var _a, _b;
    if (bumpStrategy === BumpStrategy.NOOP) {
        return;
    }
    (0, version_1.ensureStaticConfigExists)(projectDir);
    const buildGradle = await (0, gradleUtils_1.getAppBuildGradleAsync)(projectDir);
    const isMultiFlavor = ((_a = buildGradle.android) === null || _a === void 0 ? void 0 : _a.productFlavors) || ((_b = buildGradle.android) === null || _b === void 0 ? void 0 : _b.flavorDimensions);
    if (isMultiFlavor) {
        throw new Error('Automatic version bumping is not supported for multi-flavor Android projects.');
    }
    await bumpVersionInAppJsonAsync({ bumpStrategy, projectDir, exp });
    log_1.default.log('Updated versions in app.json');
    await writeVersionsToBuildGradleAsync({
        projectDir,
        exp,
    });
    log_1.default.log('Synchronized versions with build gradle');
}
exports.bumpVersionAsync = bumpVersionAsync;
async function bumpVersionInAppJsonAsync({ bumpStrategy, projectDir, exp, }) {
    var _a;
    if (bumpStrategy === BumpStrategy.NOOP) {
        return;
    }
    (0, version_1.ensureStaticConfigExists)(projectDir);
    log_1.default.addNewLineIfNone();
    if (bumpStrategy === BumpStrategy.APP_VERSION) {
        const appVersion = (_a = config_plugins_1.AndroidConfig.Version.getVersionName(exp)) !== null && _a !== void 0 ? _a : '1.0.0';
        await (0, version_1.bumpAppVersionAsync)({ appVersion, projectDir, exp });
    }
    else {
        const versionCode = config_plugins_1.AndroidConfig.Version.getVersionCode(exp);
        const bumpedVersionCode = versionCode + 1;
        log_1.default.log(`Bumping ${chalk_1.default.bold('expo.android.versionCode')} from ${chalk_1.default.bold(versionCode)} to ${chalk_1.default.bold(bumpedVersionCode)}`);
        await (0, appJson_1.updateAppJsonConfigAsync)({ projectDir, exp }, config => {
            config.android = { ...config.android, versionCode: bumpedVersionCode };
        });
    }
}
exports.bumpVersionInAppJsonAsync = bumpVersionInAppJsonAsync;
async function maybeResolveVersionsAsync(projectDir, exp, buildProfile) {
    var _a, _b;
    const workflow = await (0, workflow_1.resolveWorkflowAsync)(projectDir, eas_build_job_1.Platform.ANDROID);
    if (workflow === eas_build_job_1.Workflow.GENERIC) {
        const buildGradle = await (0, gradleUtils_1.getAppBuildGradleAsync)(projectDir);
        try {
            const parsedGradleCommand = buildProfile.gradleCommand
                ? (0, gradleUtils_1.parseGradleCommand)(buildProfile.gradleCommand, buildGradle)
                : undefined;
            return {
                appVersion: (_a = (0, gradleUtils_1.resolveConfigValue)(buildGradle, 'versionName', parsedGradleCommand === null || parsedGradleCommand === void 0 ? void 0 : parsedGradleCommand.flavor)) !== null && _a !== void 0 ? _a : '1.0.0',
                appBuildVersion: (_b = (0, gradleUtils_1.resolveConfigValue)(buildGradle, 'versionCode', parsedGradleCommand === null || parsedGradleCommand === void 0 ? void 0 : parsedGradleCommand.flavor)) !== null && _b !== void 0 ? _b : '1',
            };
        }
        catch (err) {
            return {};
        }
    }
    else {
        return {
            appBuildVersion: String(config_plugins_1.AndroidConfig.Version.getVersionCode(exp)),
            appVersion: exp.version,
        };
    }
}
exports.maybeResolveVersionsAsync = maybeResolveVersionsAsync;
async function writeVersionsToBuildGradleAsync({ projectDir, exp, }) {
    const buildGradle = await readBuildGradleAsync(projectDir);
    if (!buildGradle) {
        throw new Error('This project is missing a build.gradle file.');
    }
    let updatedBuildGradle = config_plugins_1.AndroidConfig.Version.setVersionName(exp, buildGradle);
    updatedBuildGradle = config_plugins_1.AndroidConfig.Version.setVersionCode(exp, updatedBuildGradle);
    await writeBuildGradleAsync({ projectDir, buildGradle: updatedBuildGradle });
    return updatedBuildGradle;
}
async function readBuildGradleAsync(projectDir) {
    const buildGradlePath = config_plugins_1.AndroidConfig.Paths.getAppBuildGradleFilePath(projectDir);
    if (!(await fs_extra_1.default.pathExists(buildGradlePath))) {
        return undefined;
    }
    return await fs_extra_1.default.readFile(buildGradlePath, 'utf8');
}
async function writeBuildGradleAsync({ projectDir, buildGradle, }) {
    const buildGradlePath = config_plugins_1.AndroidConfig.Paths.getAppBuildGradleFilePath(projectDir);
    await fs_extra_1.default.writeFile(buildGradlePath, buildGradle);
}
