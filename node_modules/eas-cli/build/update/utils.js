"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateBuildProfileConfigMatchesProjectConfigAsync = exports.checkEASUpdateURLIsSetAsync = exports.getBranchDescription = exports.getUpdateGroupDescriptionsWithBranch = exports.getUpdateGroupDescriptions = exports.getUpdateJsonInfosForUpdates = exports.formatUpdateTitle = exports.ensureValidVersions = exports.formatUpdateMessage = exports.truncateString = exports.formatPlatformForUpdateGroup = exports.getPlatformsForGroup = exports.formatBranch = exports.formatUpdateGroup = exports.UPDATE_COLUMNS_WITH_BRANCH = exports.UPDATE_COLUMNS = void 0;
const tslib_1 = require("tslib");
const timeago_js_1 = require("@expo/timeago.js");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const dateformat_1 = tslib_1.__importDefault(require("dateformat"));
const api_1 = require("../api");
const log_1 = tslib_1.__importStar(require("../log"));
const platform_1 = require("../platform");
const prompts_1 = require("../prompts");
const User_1 = require("../user/User");
const groupBy_1 = tslib_1.__importDefault(require("../utils/expodash/groupBy"));
const formatFields_1 = tslib_1.__importDefault(require("../utils/formatFields"));
exports.UPDATE_COLUMNS = [
    'Update message',
    'Update runtime version',
    'Update group ID',
    'Update platforms',
];
exports.UPDATE_COLUMNS_WITH_BRANCH = ['Branch', ...exports.UPDATE_COLUMNS];
function formatUpdateGroup(update) {
    var _a;
    return (0, formatFields_1.default)([
        { label: 'Platforms', value: update.platforms },
        { label: 'Runtime Version', value: update.runtimeVersion },
        { label: 'Message', value: update.message },
        { label: 'Code Signing Key', value: (_a = update.codeSigningKey) !== null && _a !== void 0 ? _a : 'N/A' },
        { label: 'Is Roll Back to Embedded', value: update.isRollBackToEmbedded ? 'Yes' : 'No' },
        { label: 'Group ID', value: update.group },
    ]);
}
exports.formatUpdateGroup = formatUpdateGroup;
function formatBranch({ branch, branchRolloutPercentage, update, }) {
    var _a, _b, _c, _d;
    const rolloutField = branchRolloutPercentage
        ? [{ label: 'Rollout', value: `${branchRolloutPercentage}%` }]
        : [];
    return (0, formatFields_1.default)([
        { label: 'Branch', value: branch },
        ...rolloutField,
        { label: 'Platforms', value: (_a = update === null || update === void 0 ? void 0 : update.platforms) !== null && _a !== void 0 ? _a : 'N/A' },
        { label: 'Runtime Version', value: (_b = update === null || update === void 0 ? void 0 : update.runtimeVersion) !== null && _b !== void 0 ? _b : 'N/A' },
        { label: 'Message', value: (_c = update === null || update === void 0 ? void 0 : update.message) !== null && _c !== void 0 ? _c : 'N/A' },
        { label: 'Group ID', value: (_d = update === null || update === void 0 ? void 0 : update.group) !== null && _d !== void 0 ? _d : 'N/A' },
    ]);
}
exports.formatBranch = formatBranch;
function getPlatformsForGroup({ group, updates = [], }) {
    const groupedUpdates = (0, groupBy_1.default)(updates, update => update.group);
    return formatPlatformForUpdateGroup(group ? groupedUpdates[group] : undefined);
}
exports.getPlatformsForGroup = getPlatformsForGroup;
function formatPlatformForUpdateGroup(updateGroup) {
    return !updateGroup || updateGroup.length === 0
        ? 'N/A'
        : updateGroup
            .map(update => update.platform)
            .sort()
            .join(', ');
}
exports.formatPlatformForUpdateGroup = formatPlatformForUpdateGroup;
function truncateString(originalMessage, length = 512) {
    if (originalMessage.length > length) {
        return originalMessage.substring(0, length - 3) + '...';
    }
    return originalMessage;
}
exports.truncateString = truncateString;
function formatUpdateMessage(update) {
    if (!update) {
        return 'N/A';
    }
    const message = update.message ? `"${truncateString(update.message)}" ` : '';
    return `${message}(${(0, timeago_js_1.format)(update.createdAt, 'en_US')} by ${(0, User_1.getActorDisplayName)(update.actor)})`;
}
exports.formatUpdateMessage = formatUpdateMessage;
function ensureValidVersions(exp, platform) {
    var _a, _b;
    const error = new Error(`Couldn't find either ${chalk_1.default.bold('runtimeVersion')} or ${chalk_1.default.bold('sdkVersion')} to configure ${chalk_1.default.bold('expo-updates')}. Specify at least one of these properties under the ${chalk_1.default.bold('expo')} key in ${chalk_1.default.bold('app.json')}. ${(0, log_1.learnMore)('https://docs.expo.dev/eas-update/runtime-versions/')}`);
    if ([platform_1.RequestedPlatform.Android, platform_1.RequestedPlatform.All].includes(platform) &&
        !(((_a = exp.android) === null || _a === void 0 ? void 0 : _a.runtimeVersion) || exp.runtimeVersion) &&
        !exp.sdkVersion) {
        throw error;
    }
    if ([platform_1.RequestedPlatform.Ios, platform_1.RequestedPlatform.All].includes(platform) &&
        !(((_b = exp.ios) === null || _b === void 0 ? void 0 : _b.runtimeVersion) || exp.runtimeVersion) &&
        !exp.sdkVersion) {
        throw error;
    }
}
exports.ensureValidVersions = ensureValidVersions;
function formatUpdateTitle(update) {
    const { message, createdAt, actor, runtimeVersion } = update;
    let actorName;
    switch (actor === null || actor === void 0 ? void 0 : actor.__typename) {
        case 'User':
        case 'SSOUser': {
            actorName = actor.username;
            break;
        }
        case 'Robot': {
            const { firstName, id } = actor;
            actorName = firstName !== null && firstName !== void 0 ? firstName : `robot: ${id.slice(0, 4)}...`;
            break;
        }
        case undefined: {
            actorName = 'unknown';
        }
    }
    return `[${(0, dateformat_1.default)(createdAt, 'mmm dd HH:MM')} by ${actorName}, runtimeVersion: ${runtimeVersion}] ${message}`;
}
exports.formatUpdateTitle = formatUpdateTitle;
function getUpdateJsonInfosForUpdates(updates) {
    return updates.map(update => ({
        id: update.id,
        createdAt: update.createdAt,
        group: update.group,
        branch: update.branch.name,
        message: update.message,
        runtimeVersion: update.runtimeVersion,
        platform: update.platform,
        manifestPermalink: update.manifestPermalink,
        isRollBackToEmbedded: update.isRollBackToEmbedded,
        gitCommitHash: update.gitCommitHash,
    }));
}
exports.getUpdateJsonInfosForUpdates = getUpdateJsonInfosForUpdates;
function getUpdateGroupDescriptions(updateGroups) {
    return updateGroups.map(updateGroup => {
        var _a;
        return ({
            message: formatUpdateMessage(updateGroup[0]),
            runtimeVersion: updateGroup[0].runtimeVersion,
            isRollBackToEmbedded: updateGroup[0].isRollBackToEmbedded,
            codeSigningKey: (_a = updateGroup[0].codeSigningInfo) === null || _a === void 0 ? void 0 : _a.keyid,
            group: updateGroup[0].group,
            platforms: formatPlatformForUpdateGroup(updateGroup),
        });
    });
}
exports.getUpdateGroupDescriptions = getUpdateGroupDescriptions;
function getUpdateGroupDescriptionsWithBranch(updateGroups) {
    return updateGroups.map(updateGroup => {
        var _a;
        return ({
            branch: updateGroup[0].branch.name,
            message: formatUpdateMessage(updateGroup[0]),
            runtimeVersion: updateGroup[0].runtimeVersion,
            isRollBackToEmbedded: updateGroup[0].isRollBackToEmbedded,
            codeSigningKey: (_a = updateGroup[0].codeSigningInfo) === null || _a === void 0 ? void 0 : _a.keyid,
            group: updateGroup[0].group,
            platforms: formatPlatformForUpdateGroup(updateGroup),
        });
    });
}
exports.getUpdateGroupDescriptionsWithBranch = getUpdateGroupDescriptionsWithBranch;
function getBranchDescription(branch) {
    var _a;
    if (branch.updates.length === 0) {
        return { branch: branch.name };
    }
    const latestUpdate = branch.updates[0];
    return {
        branch: branch.name,
        update: {
            message: formatUpdateMessage(latestUpdate),
            runtimeVersion: latestUpdate.runtimeVersion,
            isRollBackToEmbedded: latestUpdate.isRollBackToEmbedded,
            codeSigningKey: (_a = latestUpdate.codeSigningInfo) === null || _a === void 0 ? void 0 : _a.keyid,
            group: latestUpdate.group,
            platforms: getPlatformsForGroup({
                group: latestUpdate.group,
                updates: branch.updates,
            }),
        },
    };
}
exports.getBranchDescription = getBranchDescription;
async function checkEASUpdateURLIsSetAsync(exp, projectId) {
    var _a;
    const configuredURL = (_a = exp.updates) === null || _a === void 0 ? void 0 : _a.url;
    const expectedURL = (0, api_1.getEASUpdateURL)(projectId);
    return configuredURL === expectedURL;
}
exports.checkEASUpdateURLIsSetAsync = checkEASUpdateURLIsSetAsync;
async function validateBuildProfileConfigMatchesProjectConfigAsync(exp, buildProfile, projectId, nonInteractive) {
    if ((await checkEASUpdateURLIsSetAsync(exp, projectId)) && buildProfile.profile.releaseChannel) {
        const warning = `Â» Your project is configured for EAS Update, but build profile "${buildProfile.profileName}" in ${chalk_1.default.bold('eas.json')} specifies the \`releaseChannel\` property.
  For EAS Update, you need to specify the \`channel\` property, or your build will not be able to receive any updates

  ${(0, log_1.learnMore)('https://docs.expo.dev/eas-update/getting-started/#configure-your-project')}`;
        log_1.default.warn(warning);
        if (!nonInteractive) {
            const answer = await (0, prompts_1.confirmAsync)({
                message: `Would you like to proceed?`,
            });
            if (!answer) {
                log_1.default.log('Aborting...');
                process.exit(1);
            }
        }
    }
}
exports.validateBuildProfileConfigMatchesProjectConfigAsync = validateBuildProfileConfigMatchesProjectConfigAsync;
