package expo.modules.updates.db.dao;

import android.database.Cursor;
import android.net.Uri;
import androidx.room.EntityDeletionOrUpdateAdapter;
import androidx.room.EntityInsertionAdapter;
import androidx.room.RoomDatabase;
import androidx.room.RoomSQLiteQuery;
import androidx.room.SharedSQLiteStatement;
import androidx.room.util.CursorUtil;
import androidx.room.util.DBUtil;
import androidx.room.util.StringUtil;
import androidx.sqlite.db.SupportSQLiteStatement;
import expo.modules.updates.db.Converters;
import expo.modules.updates.db.entity.AssetEntity;
import expo.modules.updates.db.entity.UpdateEntity;
import expo.modules.updates.db.enums.HashType;
import expo.modules.updates.db.enums.UpdateStatus;
import java.lang.Class;
import java.lang.Long;
import java.lang.Override;
import java.lang.String;
import java.lang.StringBuilder;
import java.lang.SuppressWarnings;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.UUID;
import javax.annotation.processing.Generated;
import org.json.JSONObject;

@Generated("androidx.room.RoomProcessor")
@SuppressWarnings({"unchecked", "deprecation"})
public final class UpdateDao_Impl extends UpdateDao {
  private final RoomDatabase __db;

  private final EntityInsertionAdapter<UpdateEntity> __insertionAdapterOfUpdateEntity;

  private final Converters __converters = new Converters();

  private final EntityDeletionOrUpdateAdapter<UpdateEntity> __deletionAdapterOfUpdateEntity;

  private final SharedSQLiteStatement __preparedStmtOf_keepUpdate;

  private final SharedSQLiteStatement __preparedStmtOf_markUpdateWithStatus;

  private final SharedSQLiteStatement __preparedStmtOf_setUpdateScopeKeyInternal;

  private final SharedSQLiteStatement __preparedStmtOf_setUpdateCommitTime;

  private final SharedSQLiteStatement __preparedStmtOf_markUpdateAccessed;

  private final SharedSQLiteStatement __preparedStmtOf_incrementSuccessfulLaunchCount;

  private final SharedSQLiteStatement __preparedStmtOf_incrementFailedLaunchCount;

  public UpdateDao_Impl(RoomDatabase __db) {
    this.__db = __db;
    this.__insertionAdapterOfUpdateEntity = new EntityInsertionAdapter<UpdateEntity>(__db) {
      @Override
      public String createQuery() {
        return "INSERT OR ABORT INTO `updates` (`id`,`commit_time`,`runtime_version`,`scope_key`,`manifest`,`launch_asset_id`,`status`,`keep`,`last_accessed`,`successful_launch_count`,`failed_launch_count`) VALUES (?,?,?,?,?,?,?,?,?,?,?)";
      }

      @Override
      public void bind(SupportSQLiteStatement stmt, UpdateEntity value) {
        final byte[] _tmp = __converters.uuidToBytes(value.getId());
        if (_tmp == null) {
          stmt.bindNull(1);
        } else {
          stmt.bindBlob(1, _tmp);
        }
        final Long _tmp_1 = __converters.dateToLong(value.getCommitTime());
        if (_tmp_1 == null) {
          stmt.bindNull(2);
        } else {
          stmt.bindLong(2, _tmp_1);
        }
        if (value.getRuntimeVersion() == null) {
          stmt.bindNull(3);
        } else {
          stmt.bindString(3, value.getRuntimeVersion());
        }
        if (value.getScopeKey() == null) {
          stmt.bindNull(4);
        } else {
          stmt.bindString(4, value.getScopeKey());
        }
        final String _tmp_2 = __converters.jsonObjectToString(value.getManifest());
        if (_tmp_2 == null) {
          stmt.bindNull(5);
        } else {
          stmt.bindString(5, _tmp_2);
        }
        if (value.getLaunchAssetId() == null) {
          stmt.bindNull(6);
        } else {
          stmt.bindLong(6, value.getLaunchAssetId());
        }
        final int _tmp_3 = __converters.statusToInt(value.getStatus());
        stmt.bindLong(7, _tmp_3);
        final int _tmp_4 = value.getKeep() ? 1 : 0;
        stmt.bindLong(8, _tmp_4);
        final Long _tmp_5 = __converters.dateToLong(value.getLastAccessed());
        if (_tmp_5 == null) {
          stmt.bindNull(9);
        } else {
          stmt.bindLong(9, _tmp_5);
        }
        stmt.bindLong(10, value.getSuccessfulLaunchCount());
        stmt.bindLong(11, value.getFailedLaunchCount());
      }
    };
    this.__deletionAdapterOfUpdateEntity = new EntityDeletionOrUpdateAdapter<UpdateEntity>(__db) {
      @Override
      public String createQuery() {
        return "DELETE FROM `updates` WHERE `id` = ?";
      }

      @Override
      public void bind(SupportSQLiteStatement stmt, UpdateEntity value) {
        final byte[] _tmp = __converters.uuidToBytes(value.getId());
        if (_tmp == null) {
          stmt.bindNull(1);
        } else {
          stmt.bindBlob(1, _tmp);
        }
      }
    };
    this.__preparedStmtOf_keepUpdate = new SharedSQLiteStatement(__db) {
      @Override
      public String createQuery() {
        final String _query = "UPDATE updates SET keep = 1 WHERE id = ?;";
        return _query;
      }
    };
    this.__preparedStmtOf_markUpdateWithStatus = new SharedSQLiteStatement(__db) {
      @Override
      public String createQuery() {
        final String _query = "UPDATE updates SET status = ? WHERE id = ?;";
        return _query;
      }
    };
    this.__preparedStmtOf_setUpdateScopeKeyInternal = new SharedSQLiteStatement(__db) {
      @Override
      public String createQuery() {
        final String _query = "UPDATE updates SET scope_key = ? WHERE id = ?;";
        return _query;
      }
    };
    this.__preparedStmtOf_setUpdateCommitTime = new SharedSQLiteStatement(__db) {
      @Override
      public String createQuery() {
        final String _query = "UPDATE updates SET commit_time = ? WHERE id = ?;";
        return _query;
      }
    };
    this.__preparedStmtOf_markUpdateAccessed = new SharedSQLiteStatement(__db) {
      @Override
      public String createQuery() {
        final String _query = "UPDATE updates SET last_accessed = ? WHERE id = ?;";
        return _query;
      }
    };
    this.__preparedStmtOf_incrementSuccessfulLaunchCount = new SharedSQLiteStatement(__db) {
      @Override
      public String createQuery() {
        final String _query = "UPDATE updates SET successful_launch_count = successful_launch_count + 1 WHERE id = ?;";
        return _query;
      }
    };
    this.__preparedStmtOf_incrementFailedLaunchCount = new SharedSQLiteStatement(__db) {
      @Override
      public String createQuery() {
        final String _query = "UPDATE updates SET failed_launch_count = failed_launch_count + 1 WHERE id = ?;";
        return _query;
      }
    };
  }

  @Override
  public void insertUpdate(final UpdateEntity update) {
    __db.assertNotSuspendingTransaction();
    __db.beginTransaction();
    try {
      __insertionAdapterOfUpdateEntity.insert(update);
      __db.setTransactionSuccessful();
    } finally {
      __db.endTransaction();
    }
  }

  @Override
  public void deleteUpdates(final List<UpdateEntity> updates) {
    __db.assertNotSuspendingTransaction();
    __db.beginTransaction();
    try {
      __deletionAdapterOfUpdateEntity.handleMultiple(updates);
      __db.setTransactionSuccessful();
    } finally {
      __db.endTransaction();
    }
  }

  @Override
  public void markUpdateFinished(final UpdateEntity update,
      final boolean hasSkippedEmbeddedAssets) {
    __db.beginTransaction();
    try {
      UpdateDao_Impl.super.markUpdateFinished(update, hasSkippedEmbeddedAssets);
      __db.setTransactionSuccessful();
    } finally {
      __db.endTransaction();
    }
  }

  @Override
  public void _keepUpdate(final UUID id) {
    __db.assertNotSuspendingTransaction();
    final SupportSQLiteStatement _stmt = __preparedStmtOf_keepUpdate.acquire();
    int _argIndex = 1;
    final byte[] _tmp = __converters.uuidToBytes(id);
    if (_tmp == null) {
      _stmt.bindNull(_argIndex);
    } else {
      _stmt.bindBlob(_argIndex, _tmp);
    }
    __db.beginTransaction();
    try {
      _stmt.executeUpdateDelete();
      __db.setTransactionSuccessful();
    } finally {
      __db.endTransaction();
      __preparedStmtOf_keepUpdate.release(_stmt);
    }
  }

  @Override
  public void _markUpdateWithStatus(final UpdateStatus status, final UUID id) {
    __db.assertNotSuspendingTransaction();
    final SupportSQLiteStatement _stmt = __preparedStmtOf_markUpdateWithStatus.acquire();
    int _argIndex = 1;
    final int _tmp = __converters.statusToInt(status);
    _stmt.bindLong(_argIndex, _tmp);
    _argIndex = 2;
    final byte[] _tmp_1 = __converters.uuidToBytes(id);
    if (_tmp_1 == null) {
      _stmt.bindNull(_argIndex);
    } else {
      _stmt.bindBlob(_argIndex, _tmp_1);
    }
    __db.beginTransaction();
    try {
      _stmt.executeUpdateDelete();
      __db.setTransactionSuccessful();
    } finally {
      __db.endTransaction();
      __preparedStmtOf_markUpdateWithStatus.release(_stmt);
    }
  }

  @Override
  public void _setUpdateScopeKeyInternal(final UUID id, final String newScopeKey) {
    __db.assertNotSuspendingTransaction();
    final SupportSQLiteStatement _stmt = __preparedStmtOf_setUpdateScopeKeyInternal.acquire();
    int _argIndex = 1;
    if (newScopeKey == null) {
      _stmt.bindNull(_argIndex);
    } else {
      _stmt.bindString(_argIndex, newScopeKey);
    }
    _argIndex = 2;
    final byte[] _tmp = __converters.uuidToBytes(id);
    if (_tmp == null) {
      _stmt.bindNull(_argIndex);
    } else {
      _stmt.bindBlob(_argIndex, _tmp);
    }
    __db.beginTransaction();
    try {
      _stmt.executeUpdateDelete();
      __db.setTransactionSuccessful();
    } finally {
      __db.endTransaction();
      __preparedStmtOf_setUpdateScopeKeyInternal.release(_stmt);
    }
  }

  @Override
  public void _setUpdateCommitTime(final UUID id, final Date commitTime) {
    __db.assertNotSuspendingTransaction();
    final SupportSQLiteStatement _stmt = __preparedStmtOf_setUpdateCommitTime.acquire();
    int _argIndex = 1;
    final Long _tmp = __converters.dateToLong(commitTime);
    if (_tmp == null) {
      _stmt.bindNull(_argIndex);
    } else {
      _stmt.bindLong(_argIndex, _tmp);
    }
    _argIndex = 2;
    final byte[] _tmp_1 = __converters.uuidToBytes(id);
    if (_tmp_1 == null) {
      _stmt.bindNull(_argIndex);
    } else {
      _stmt.bindBlob(_argIndex, _tmp_1);
    }
    __db.beginTransaction();
    try {
      _stmt.executeUpdateDelete();
      __db.setTransactionSuccessful();
    } finally {
      __db.endTransaction();
      __preparedStmtOf_setUpdateCommitTime.release(_stmt);
    }
  }

  @Override
  public void _markUpdateAccessed(final UUID id, final Date lastAccessed) {
    __db.assertNotSuspendingTransaction();
    final SupportSQLiteStatement _stmt = __preparedStmtOf_markUpdateAccessed.acquire();
    int _argIndex = 1;
    final Long _tmp = __converters.dateToLong(lastAccessed);
    if (_tmp == null) {
      _stmt.bindNull(_argIndex);
    } else {
      _stmt.bindLong(_argIndex, _tmp);
    }
    _argIndex = 2;
    final byte[] _tmp_1 = __converters.uuidToBytes(id);
    if (_tmp_1 == null) {
      _stmt.bindNull(_argIndex);
    } else {
      _stmt.bindBlob(_argIndex, _tmp_1);
    }
    __db.beginTransaction();
    try {
      _stmt.executeUpdateDelete();
      __db.setTransactionSuccessful();
    } finally {
      __db.endTransaction();
      __preparedStmtOf_markUpdateAccessed.release(_stmt);
    }
  }

  @Override
  public void _incrementSuccessfulLaunchCount(final UUID id) {
    __db.assertNotSuspendingTransaction();
    final SupportSQLiteStatement _stmt = __preparedStmtOf_incrementSuccessfulLaunchCount.acquire();
    int _argIndex = 1;
    final byte[] _tmp = __converters.uuidToBytes(id);
    if (_tmp == null) {
      _stmt.bindNull(_argIndex);
    } else {
      _stmt.bindBlob(_argIndex, _tmp);
    }
    __db.beginTransaction();
    try {
      _stmt.executeUpdateDelete();
      __db.setTransactionSuccessful();
    } finally {
      __db.endTransaction();
      __preparedStmtOf_incrementSuccessfulLaunchCount.release(_stmt);
    }
  }

  @Override
  public void _incrementFailedLaunchCount(final UUID id) {
    __db.assertNotSuspendingTransaction();
    final SupportSQLiteStatement _stmt = __preparedStmtOf_incrementFailedLaunchCount.acquire();
    int _argIndex = 1;
    final byte[] _tmp = __converters.uuidToBytes(id);
    if (_tmp == null) {
      _stmt.bindNull(_argIndex);
    } else {
      _stmt.bindBlob(_argIndex, _tmp);
    }
    __db.beginTransaction();
    try {
      _stmt.executeUpdateDelete();
      __db.setTransactionSuccessful();
    } finally {
      __db.endTransaction();
      __preparedStmtOf_incrementFailedLaunchCount.release(_stmt);
    }
  }

  @Override
  public List<UpdateEntity> _loadLaunchableUpdatesForProjectWithStatuses(final String scopeKey,
      final List<? extends UpdateStatus> statuses) {
    StringBuilder _stringBuilder = StringUtil.newStringBuilder();
    _stringBuilder.append("SELECT * FROM updates WHERE scope_key = ");
    _stringBuilder.append("?");
    _stringBuilder.append(" AND (successful_launch_count > 0 OR failed_launch_count < 1) AND status IN (");
    final int _inputSize = statuses.size();
    StringUtil.appendPlaceholders(_stringBuilder, _inputSize);
    _stringBuilder.append(");");
    final String _sql = _stringBuilder.toString();
    final int _argCount = 1 + _inputSize;
    final RoomSQLiteQuery _statement = RoomSQLiteQuery.acquire(_sql, _argCount);
    int _argIndex = 1;
    if (scopeKey == null) {
      _statement.bindNull(_argIndex);
    } else {
      _statement.bindString(_argIndex, scopeKey);
    }
    _argIndex = 2;
    for (UpdateStatus _item : statuses) {
      final int _tmp = __converters.statusToInt(_item);
      _statement.bindLong(_argIndex, _tmp);
      _argIndex ++;
    }
    __db.assertNotSuspendingTransaction();
    final Cursor _cursor = DBUtil.query(__db, _statement, false, null);
    try {
      final int _cursorIndexOfId = CursorUtil.getColumnIndexOrThrow(_cursor, "id");
      final int _cursorIndexOfCommitTime = CursorUtil.getColumnIndexOrThrow(_cursor, "commit_time");
      final int _cursorIndexOfRuntimeVersion = CursorUtil.getColumnIndexOrThrow(_cursor, "runtime_version");
      final int _cursorIndexOfScopeKey = CursorUtil.getColumnIndexOrThrow(_cursor, "scope_key");
      final int _cursorIndexOfManifest = CursorUtil.getColumnIndexOrThrow(_cursor, "manifest");
      final int _cursorIndexOfLaunchAssetId = CursorUtil.getColumnIndexOrThrow(_cursor, "launch_asset_id");
      final int _cursorIndexOfStatus = CursorUtil.getColumnIndexOrThrow(_cursor, "status");
      final int _cursorIndexOfKeep = CursorUtil.getColumnIndexOrThrow(_cursor, "keep");
      final int _cursorIndexOfLastAccessed = CursorUtil.getColumnIndexOrThrow(_cursor, "last_accessed");
      final int _cursorIndexOfSuccessfulLaunchCount = CursorUtil.getColumnIndexOrThrow(_cursor, "successful_launch_count");
      final int _cursorIndexOfFailedLaunchCount = CursorUtil.getColumnIndexOrThrow(_cursor, "failed_launch_count");
      final List<UpdateEntity> _result = new ArrayList<UpdateEntity>(_cursor.getCount());
      while(_cursor.moveToNext()) {
        final UpdateEntity _item_1;
        final UUID _tmpId;
        final byte[] _tmp_1;
        if (_cursor.isNull(_cursorIndexOfId)) {
          _tmp_1 = null;
        } else {
          _tmp_1 = _cursor.getBlob(_cursorIndexOfId);
        }
        _tmpId = __converters.bytesToUuid(_tmp_1);
        final Date _tmpCommitTime;
        final Long _tmp_2;
        if (_cursor.isNull(_cursorIndexOfCommitTime)) {
          _tmp_2 = null;
        } else {
          _tmp_2 = _cursor.getLong(_cursorIndexOfCommitTime);
        }
        _tmpCommitTime = __converters.longToDate(_tmp_2);
        final String _tmpRuntimeVersion;
        if (_cursor.isNull(_cursorIndexOfRuntimeVersion)) {
          _tmpRuntimeVersion = null;
        } else {
          _tmpRuntimeVersion = _cursor.getString(_cursorIndexOfRuntimeVersion);
        }
        final String _tmpScopeKey;
        if (_cursor.isNull(_cursorIndexOfScopeKey)) {
          _tmpScopeKey = null;
        } else {
          _tmpScopeKey = _cursor.getString(_cursorIndexOfScopeKey);
        }
        final JSONObject _tmpManifest;
        final String _tmp_3;
        if (_cursor.isNull(_cursorIndexOfManifest)) {
          _tmp_3 = null;
        } else {
          _tmp_3 = _cursor.getString(_cursorIndexOfManifest);
        }
        _tmpManifest = __converters.stringToJsonObject(_tmp_3);
        _item_1 = new UpdateEntity(_tmpId,_tmpCommitTime,_tmpRuntimeVersion,_tmpScopeKey,_tmpManifest);
        final Long _tmpLaunchAssetId;
        if (_cursor.isNull(_cursorIndexOfLaunchAssetId)) {
          _tmpLaunchAssetId = null;
        } else {
          _tmpLaunchAssetId = _cursor.getLong(_cursorIndexOfLaunchAssetId);
        }
        _item_1.setLaunchAssetId(_tmpLaunchAssetId);
        final UpdateStatus _tmpStatus;
        final int _tmp_4;
        _tmp_4 = _cursor.getInt(_cursorIndexOfStatus);
        _tmpStatus = __converters.intToStatus(_tmp_4);
        _item_1.setStatus(_tmpStatus);
        final boolean _tmpKeep;
        final int _tmp_5;
        _tmp_5 = _cursor.getInt(_cursorIndexOfKeep);
        _tmpKeep = _tmp_5 != 0;
        _item_1.setKeep(_tmpKeep);
        final Date _tmpLastAccessed;
        final Long _tmp_6;
        if (_cursor.isNull(_cursorIndexOfLastAccessed)) {
          _tmp_6 = null;
        } else {
          _tmp_6 = _cursor.getLong(_cursorIndexOfLastAccessed);
        }
        _tmpLastAccessed = __converters.longToDate(_tmp_6);
        _item_1.setLastAccessed(_tmpLastAccessed);
        final int _tmpSuccessfulLaunchCount;
        _tmpSuccessfulLaunchCount = _cursor.getInt(_cursorIndexOfSuccessfulLaunchCount);
        _item_1.setSuccessfulLaunchCount(_tmpSuccessfulLaunchCount);
        final int _tmpFailedLaunchCount;
        _tmpFailedLaunchCount = _cursor.getInt(_cursorIndexOfFailedLaunchCount);
        _item_1.setFailedLaunchCount(_tmpFailedLaunchCount);
        _result.add(_item_1);
      }
      return _result;
    } finally {
      _cursor.close();
      _statement.release();
    }
  }

  @Override
  public List<UpdateEntity> _loadUpdatesWithId(final UUID id) {
    final String _sql = "SELECT * FROM updates WHERE id = ?;";
    final RoomSQLiteQuery _statement = RoomSQLiteQuery.acquire(_sql, 1);
    int _argIndex = 1;
    final byte[] _tmp = __converters.uuidToBytes(id);
    if (_tmp == null) {
      _statement.bindNull(_argIndex);
    } else {
      _statement.bindBlob(_argIndex, _tmp);
    }
    __db.assertNotSuspendingTransaction();
    final Cursor _cursor = DBUtil.query(__db, _statement, false, null);
    try {
      final int _cursorIndexOfId = CursorUtil.getColumnIndexOrThrow(_cursor, "id");
      final int _cursorIndexOfCommitTime = CursorUtil.getColumnIndexOrThrow(_cursor, "commit_time");
      final int _cursorIndexOfRuntimeVersion = CursorUtil.getColumnIndexOrThrow(_cursor, "runtime_version");
      final int _cursorIndexOfScopeKey = CursorUtil.getColumnIndexOrThrow(_cursor, "scope_key");
      final int _cursorIndexOfManifest = CursorUtil.getColumnIndexOrThrow(_cursor, "manifest");
      final int _cursorIndexOfLaunchAssetId = CursorUtil.getColumnIndexOrThrow(_cursor, "launch_asset_id");
      final int _cursorIndexOfStatus = CursorUtil.getColumnIndexOrThrow(_cursor, "status");
      final int _cursorIndexOfKeep = CursorUtil.getColumnIndexOrThrow(_cursor, "keep");
      final int _cursorIndexOfLastAccessed = CursorUtil.getColumnIndexOrThrow(_cursor, "last_accessed");
      final int _cursorIndexOfSuccessfulLaunchCount = CursorUtil.getColumnIndexOrThrow(_cursor, "successful_launch_count");
      final int _cursorIndexOfFailedLaunchCount = CursorUtil.getColumnIndexOrThrow(_cursor, "failed_launch_count");
      final List<UpdateEntity> _result = new ArrayList<UpdateEntity>(_cursor.getCount());
      while(_cursor.moveToNext()) {
        final UpdateEntity _item;
        final UUID _tmpId;
        final byte[] _tmp_1;
        if (_cursor.isNull(_cursorIndexOfId)) {
          _tmp_1 = null;
        } else {
          _tmp_1 = _cursor.getBlob(_cursorIndexOfId);
        }
        _tmpId = __converters.bytesToUuid(_tmp_1);
        final Date _tmpCommitTime;
        final Long _tmp_2;
        if (_cursor.isNull(_cursorIndexOfCommitTime)) {
          _tmp_2 = null;
        } else {
          _tmp_2 = _cursor.getLong(_cursorIndexOfCommitTime);
        }
        _tmpCommitTime = __converters.longToDate(_tmp_2);
        final String _tmpRuntimeVersion;
        if (_cursor.isNull(_cursorIndexOfRuntimeVersion)) {
          _tmpRuntimeVersion = null;
        } else {
          _tmpRuntimeVersion = _cursor.getString(_cursorIndexOfRuntimeVersion);
        }
        final String _tmpScopeKey;
        if (_cursor.isNull(_cursorIndexOfScopeKey)) {
          _tmpScopeKey = null;
        } else {
          _tmpScopeKey = _cursor.getString(_cursorIndexOfScopeKey);
        }
        final JSONObject _tmpManifest;
        final String _tmp_3;
        if (_cursor.isNull(_cursorIndexOfManifest)) {
          _tmp_3 = null;
        } else {
          _tmp_3 = _cursor.getString(_cursorIndexOfManifest);
        }
        _tmpManifest = __converters.stringToJsonObject(_tmp_3);
        _item = new UpdateEntity(_tmpId,_tmpCommitTime,_tmpRuntimeVersion,_tmpScopeKey,_tmpManifest);
        final Long _tmpLaunchAssetId;
        if (_cursor.isNull(_cursorIndexOfLaunchAssetId)) {
          _tmpLaunchAssetId = null;
        } else {
          _tmpLaunchAssetId = _cursor.getLong(_cursorIndexOfLaunchAssetId);
        }
        _item.setLaunchAssetId(_tmpLaunchAssetId);
        final UpdateStatus _tmpStatus;
        final int _tmp_4;
        _tmp_4 = _cursor.getInt(_cursorIndexOfStatus);
        _tmpStatus = __converters.intToStatus(_tmp_4);
        _item.setStatus(_tmpStatus);
        final boolean _tmpKeep;
        final int _tmp_5;
        _tmp_5 = _cursor.getInt(_cursorIndexOfKeep);
        _tmpKeep = _tmp_5 != 0;
        _item.setKeep(_tmpKeep);
        final Date _tmpLastAccessed;
        final Long _tmp_6;
        if (_cursor.isNull(_cursorIndexOfLastAccessed)) {
          _tmp_6 = null;
        } else {
          _tmp_6 = _cursor.getLong(_cursorIndexOfLastAccessed);
        }
        _tmpLastAccessed = __converters.longToDate(_tmp_6);
        _item.setLastAccessed(_tmpLastAccessed);
        final int _tmpSuccessfulLaunchCount;
        _tmpSuccessfulLaunchCount = _cursor.getInt(_cursorIndexOfSuccessfulLaunchCount);
        _item.setSuccessfulLaunchCount(_tmpSuccessfulLaunchCount);
        final int _tmpFailedLaunchCount;
        _tmpFailedLaunchCount = _cursor.getInt(_cursorIndexOfFailedLaunchCount);
        _item.setFailedLaunchCount(_tmpFailedLaunchCount);
        _result.add(_item);
      }
      return _result;
    } finally {
      _cursor.close();
      _statement.release();
    }
  }

  @Override
  public AssetEntity _loadLaunchAsset(final UUID id) {
    final String _sql = "SELECT assets.* FROM assets INNER JOIN updates ON updates.launch_asset_id = assets.id WHERE updates.id = ?;";
    final RoomSQLiteQuery _statement = RoomSQLiteQuery.acquire(_sql, 1);
    int _argIndex = 1;
    final byte[] _tmp = __converters.uuidToBytes(id);
    if (_tmp == null) {
      _statement.bindNull(_argIndex);
    } else {
      _statement.bindBlob(_argIndex, _tmp);
    }
    __db.assertNotSuspendingTransaction();
    final Cursor _cursor = DBUtil.query(__db, _statement, false, null);
    try {
      final int _cursorIndexOfKey = CursorUtil.getColumnIndexOrThrow(_cursor, "key");
      final int _cursorIndexOfType = CursorUtil.getColumnIndexOrThrow(_cursor, "type");
      final int _cursorIndexOfId = CursorUtil.getColumnIndexOrThrow(_cursor, "id");
      final int _cursorIndexOfUrl = CursorUtil.getColumnIndexOrThrow(_cursor, "url");
      final int _cursorIndexOfHeaders = CursorUtil.getColumnIndexOrThrow(_cursor, "headers");
      final int _cursorIndexOfExtraRequestHeaders = CursorUtil.getColumnIndexOrThrow(_cursor, "extra_request_headers");
      final int _cursorIndexOfMetadata = CursorUtil.getColumnIndexOrThrow(_cursor, "metadata");
      final int _cursorIndexOfDownloadTime = CursorUtil.getColumnIndexOrThrow(_cursor, "download_time");
      final int _cursorIndexOfRelativePath = CursorUtil.getColumnIndexOrThrow(_cursor, "relative_path");
      final int _cursorIndexOfHash = CursorUtil.getColumnIndexOrThrow(_cursor, "hash");
      final int _cursorIndexOfHashType = CursorUtil.getColumnIndexOrThrow(_cursor, "hash_type");
      final int _cursorIndexOfExpectedHash = CursorUtil.getColumnIndexOrThrow(_cursor, "expected_hash");
      final int _cursorIndexOfMarkedForDeletion = CursorUtil.getColumnIndexOrThrow(_cursor, "marked_for_deletion");
      final AssetEntity _result;
      if(_cursor.moveToFirst()) {
        final String _tmpKey;
        if (_cursor.isNull(_cursorIndexOfKey)) {
          _tmpKey = null;
        } else {
          _tmpKey = _cursor.getString(_cursorIndexOfKey);
        }
        final String _tmpType;
        if (_cursor.isNull(_cursorIndexOfType)) {
          _tmpType = null;
        } else {
          _tmpType = _cursor.getString(_cursorIndexOfType);
        }
        _result = new AssetEntity(_tmpKey,_tmpType);
        final long _tmpId;
        _tmpId = _cursor.getLong(_cursorIndexOfId);
        _result.setId(_tmpId);
        final Uri _tmpUrl;
        final String _tmp_1;
        if (_cursor.isNull(_cursorIndexOfUrl)) {
          _tmp_1 = null;
        } else {
          _tmp_1 = _cursor.getString(_cursorIndexOfUrl);
        }
        _tmpUrl = __converters.stringToUri(_tmp_1);
        _result.setUrl(_tmpUrl);
        final JSONObject _tmpHeaders;
        final String _tmp_2;
        if (_cursor.isNull(_cursorIndexOfHeaders)) {
          _tmp_2 = null;
        } else {
          _tmp_2 = _cursor.getString(_cursorIndexOfHeaders);
        }
        _tmpHeaders = __converters.stringToJsonObject(_tmp_2);
        _result.setHeaders(_tmpHeaders);
        final JSONObject _tmpExtraRequestHeaders;
        final String _tmp_3;
        if (_cursor.isNull(_cursorIndexOfExtraRequestHeaders)) {
          _tmp_3 = null;
        } else {
          _tmp_3 = _cursor.getString(_cursorIndexOfExtraRequestHeaders);
        }
        _tmpExtraRequestHeaders = __converters.stringToJsonObject(_tmp_3);
        _result.setExtraRequestHeaders(_tmpExtraRequestHeaders);
        final JSONObject _tmpMetadata;
        final String _tmp_4;
        if (_cursor.isNull(_cursorIndexOfMetadata)) {
          _tmp_4 = null;
        } else {
          _tmp_4 = _cursor.getString(_cursorIndexOfMetadata);
        }
        _tmpMetadata = __converters.stringToJsonObject(_tmp_4);
        _result.setMetadata(_tmpMetadata);
        final Date _tmpDownloadTime;
        final Long _tmp_5;
        if (_cursor.isNull(_cursorIndexOfDownloadTime)) {
          _tmp_5 = null;
        } else {
          _tmp_5 = _cursor.getLong(_cursorIndexOfDownloadTime);
        }
        _tmpDownloadTime = __converters.longToDate(_tmp_5);
        _result.setDownloadTime(_tmpDownloadTime);
        final String _tmpRelativePath;
        if (_cursor.isNull(_cursorIndexOfRelativePath)) {
          _tmpRelativePath = null;
        } else {
          _tmpRelativePath = _cursor.getString(_cursorIndexOfRelativePath);
        }
        _result.setRelativePath(_tmpRelativePath);
        final byte[] _tmpHash;
        if (_cursor.isNull(_cursorIndexOfHash)) {
          _tmpHash = null;
        } else {
          _tmpHash = _cursor.getBlob(_cursorIndexOfHash);
        }
        _result.setHash(_tmpHash);
        final HashType _tmpHashType;
        final int _tmp_6;
        _tmp_6 = _cursor.getInt(_cursorIndexOfHashType);
        _tmpHashType = __converters.intToHashType(_tmp_6);
        _result.setHashType(_tmpHashType);
        final String _tmpExpectedHash;
        if (_cursor.isNull(_cursorIndexOfExpectedHash)) {
          _tmpExpectedHash = null;
        } else {
          _tmpExpectedHash = _cursor.getString(_cursorIndexOfExpectedHash);
        }
        _result.setExpectedHash(_tmpExpectedHash);
        final boolean _tmpMarkedForDeletion;
        final int _tmp_7;
        _tmp_7 = _cursor.getInt(_cursorIndexOfMarkedForDeletion);
        _tmpMarkedForDeletion = _tmp_7 != 0;
        _result.setMarkedForDeletion(_tmpMarkedForDeletion);
      } else {
        _result = null;
      }
      return _result;
    } finally {
      _cursor.close();
      _statement.release();
    }
  }

  @Override
  public List<UpdateEntity> loadAllUpdates() {
    final String _sql = "SELECT * FROM updates;";
    final RoomSQLiteQuery _statement = RoomSQLiteQuery.acquire(_sql, 0);
    __db.assertNotSuspendingTransaction();
    final Cursor _cursor = DBUtil.query(__db, _statement, false, null);
    try {
      final int _cursorIndexOfId = CursorUtil.getColumnIndexOrThrow(_cursor, "id");
      final int _cursorIndexOfCommitTime = CursorUtil.getColumnIndexOrThrow(_cursor, "commit_time");
      final int _cursorIndexOfRuntimeVersion = CursorUtil.getColumnIndexOrThrow(_cursor, "runtime_version");
      final int _cursorIndexOfScopeKey = CursorUtil.getColumnIndexOrThrow(_cursor, "scope_key");
      final int _cursorIndexOfManifest = CursorUtil.getColumnIndexOrThrow(_cursor, "manifest");
      final int _cursorIndexOfLaunchAssetId = CursorUtil.getColumnIndexOrThrow(_cursor, "launch_asset_id");
      final int _cursorIndexOfStatus = CursorUtil.getColumnIndexOrThrow(_cursor, "status");
      final int _cursorIndexOfKeep = CursorUtil.getColumnIndexOrThrow(_cursor, "keep");
      final int _cursorIndexOfLastAccessed = CursorUtil.getColumnIndexOrThrow(_cursor, "last_accessed");
      final int _cursorIndexOfSuccessfulLaunchCount = CursorUtil.getColumnIndexOrThrow(_cursor, "successful_launch_count");
      final int _cursorIndexOfFailedLaunchCount = CursorUtil.getColumnIndexOrThrow(_cursor, "failed_launch_count");
      final List<UpdateEntity> _result = new ArrayList<UpdateEntity>(_cursor.getCount());
      while(_cursor.moveToNext()) {
        final UpdateEntity _item;
        final UUID _tmpId;
        final byte[] _tmp;
        if (_cursor.isNull(_cursorIndexOfId)) {
          _tmp = null;
        } else {
          _tmp = _cursor.getBlob(_cursorIndexOfId);
        }
        _tmpId = __converters.bytesToUuid(_tmp);
        final Date _tmpCommitTime;
        final Long _tmp_1;
        if (_cursor.isNull(_cursorIndexOfCommitTime)) {
          _tmp_1 = null;
        } else {
          _tmp_1 = _cursor.getLong(_cursorIndexOfCommitTime);
        }
        _tmpCommitTime = __converters.longToDate(_tmp_1);
        final String _tmpRuntimeVersion;
        if (_cursor.isNull(_cursorIndexOfRuntimeVersion)) {
          _tmpRuntimeVersion = null;
        } else {
          _tmpRuntimeVersion = _cursor.getString(_cursorIndexOfRuntimeVersion);
        }
        final String _tmpScopeKey;
        if (_cursor.isNull(_cursorIndexOfScopeKey)) {
          _tmpScopeKey = null;
        } else {
          _tmpScopeKey = _cursor.getString(_cursorIndexOfScopeKey);
        }
        final JSONObject _tmpManifest;
        final String _tmp_2;
        if (_cursor.isNull(_cursorIndexOfManifest)) {
          _tmp_2 = null;
        } else {
          _tmp_2 = _cursor.getString(_cursorIndexOfManifest);
        }
        _tmpManifest = __converters.stringToJsonObject(_tmp_2);
        _item = new UpdateEntity(_tmpId,_tmpCommitTime,_tmpRuntimeVersion,_tmpScopeKey,_tmpManifest);
        final Long _tmpLaunchAssetId;
        if (_cursor.isNull(_cursorIndexOfLaunchAssetId)) {
          _tmpLaunchAssetId = null;
        } else {
          _tmpLaunchAssetId = _cursor.getLong(_cursorIndexOfLaunchAssetId);
        }
        _item.setLaunchAssetId(_tmpLaunchAssetId);
        final UpdateStatus _tmpStatus;
        final int _tmp_3;
        _tmp_3 = _cursor.getInt(_cursorIndexOfStatus);
        _tmpStatus = __converters.intToStatus(_tmp_3);
        _item.setStatus(_tmpStatus);
        final boolean _tmpKeep;
        final int _tmp_4;
        _tmp_4 = _cursor.getInt(_cursorIndexOfKeep);
        _tmpKeep = _tmp_4 != 0;
        _item.setKeep(_tmpKeep);
        final Date _tmpLastAccessed;
        final Long _tmp_5;
        if (_cursor.isNull(_cursorIndexOfLastAccessed)) {
          _tmp_5 = null;
        } else {
          _tmp_5 = _cursor.getLong(_cursorIndexOfLastAccessed);
        }
        _tmpLastAccessed = __converters.longToDate(_tmp_5);
        _item.setLastAccessed(_tmpLastAccessed);
        final int _tmpSuccessfulLaunchCount;
        _tmpSuccessfulLaunchCount = _cursor.getInt(_cursorIndexOfSuccessfulLaunchCount);
        _item.setSuccessfulLaunchCount(_tmpSuccessfulLaunchCount);
        final int _tmpFailedLaunchCount;
        _tmpFailedLaunchCount = _cursor.getInt(_cursorIndexOfFailedLaunchCount);
        _item.setFailedLaunchCount(_tmpFailedLaunchCount);
        _result.add(_item);
      }
      return _result;
    } finally {
      _cursor.close();
      _statement.release();
    }
  }

  @Override
  public List<UpdateEntity> loadAllUpdatesWithStatus(final UpdateStatus status) {
    final String _sql = "SELECT * FROM updates WHERE status = ?;";
    final RoomSQLiteQuery _statement = RoomSQLiteQuery.acquire(_sql, 1);
    int _argIndex = 1;
    final int _tmp = __converters.statusToInt(status);
    _statement.bindLong(_argIndex, _tmp);
    __db.assertNotSuspendingTransaction();
    final Cursor _cursor = DBUtil.query(__db, _statement, false, null);
    try {
      final int _cursorIndexOfId = CursorUtil.getColumnIndexOrThrow(_cursor, "id");
      final int _cursorIndexOfCommitTime = CursorUtil.getColumnIndexOrThrow(_cursor, "commit_time");
      final int _cursorIndexOfRuntimeVersion = CursorUtil.getColumnIndexOrThrow(_cursor, "runtime_version");
      final int _cursorIndexOfScopeKey = CursorUtil.getColumnIndexOrThrow(_cursor, "scope_key");
      final int _cursorIndexOfManifest = CursorUtil.getColumnIndexOrThrow(_cursor, "manifest");
      final int _cursorIndexOfLaunchAssetId = CursorUtil.getColumnIndexOrThrow(_cursor, "launch_asset_id");
      final int _cursorIndexOfStatus = CursorUtil.getColumnIndexOrThrow(_cursor, "status");
      final int _cursorIndexOfKeep = CursorUtil.getColumnIndexOrThrow(_cursor, "keep");
      final int _cursorIndexOfLastAccessed = CursorUtil.getColumnIndexOrThrow(_cursor, "last_accessed");
      final int _cursorIndexOfSuccessfulLaunchCount = CursorUtil.getColumnIndexOrThrow(_cursor, "successful_launch_count");
      final int _cursorIndexOfFailedLaunchCount = CursorUtil.getColumnIndexOrThrow(_cursor, "failed_launch_count");
      final List<UpdateEntity> _result = new ArrayList<UpdateEntity>(_cursor.getCount());
      while(_cursor.moveToNext()) {
        final UpdateEntity _item;
        final UUID _tmpId;
        final byte[] _tmp_1;
        if (_cursor.isNull(_cursorIndexOfId)) {
          _tmp_1 = null;
        } else {
          _tmp_1 = _cursor.getBlob(_cursorIndexOfId);
        }
        _tmpId = __converters.bytesToUuid(_tmp_1);
        final Date _tmpCommitTime;
        final Long _tmp_2;
        if (_cursor.isNull(_cursorIndexOfCommitTime)) {
          _tmp_2 = null;
        } else {
          _tmp_2 = _cursor.getLong(_cursorIndexOfCommitTime);
        }
        _tmpCommitTime = __converters.longToDate(_tmp_2);
        final String _tmpRuntimeVersion;
        if (_cursor.isNull(_cursorIndexOfRuntimeVersion)) {
          _tmpRuntimeVersion = null;
        } else {
          _tmpRuntimeVersion = _cursor.getString(_cursorIndexOfRuntimeVersion);
        }
        final String _tmpScopeKey;
        if (_cursor.isNull(_cursorIndexOfScopeKey)) {
          _tmpScopeKey = null;
        } else {
          _tmpScopeKey = _cursor.getString(_cursorIndexOfScopeKey);
        }
        final JSONObject _tmpManifest;
        final String _tmp_3;
        if (_cursor.isNull(_cursorIndexOfManifest)) {
          _tmp_3 = null;
        } else {
          _tmp_3 = _cursor.getString(_cursorIndexOfManifest);
        }
        _tmpManifest = __converters.stringToJsonObject(_tmp_3);
        _item = new UpdateEntity(_tmpId,_tmpCommitTime,_tmpRuntimeVersion,_tmpScopeKey,_tmpManifest);
        final Long _tmpLaunchAssetId;
        if (_cursor.isNull(_cursorIndexOfLaunchAssetId)) {
          _tmpLaunchAssetId = null;
        } else {
          _tmpLaunchAssetId = _cursor.getLong(_cursorIndexOfLaunchAssetId);
        }
        _item.setLaunchAssetId(_tmpLaunchAssetId);
        final UpdateStatus _tmpStatus;
        final int _tmp_4;
        _tmp_4 = _cursor.getInt(_cursorIndexOfStatus);
        _tmpStatus = __converters.intToStatus(_tmp_4);
        _item.setStatus(_tmpStatus);
        final boolean _tmpKeep;
        final int _tmp_5;
        _tmp_5 = _cursor.getInt(_cursorIndexOfKeep);
        _tmpKeep = _tmp_5 != 0;
        _item.setKeep(_tmpKeep);
        final Date _tmpLastAccessed;
        final Long _tmp_6;
        if (_cursor.isNull(_cursorIndexOfLastAccessed)) {
          _tmp_6 = null;
        } else {
          _tmp_6 = _cursor.getLong(_cursorIndexOfLastAccessed);
        }
        _tmpLastAccessed = __converters.longToDate(_tmp_6);
        _item.setLastAccessed(_tmpLastAccessed);
        final int _tmpSuccessfulLaunchCount;
        _tmpSuccessfulLaunchCount = _cursor.getInt(_cursorIndexOfSuccessfulLaunchCount);
        _item.setSuccessfulLaunchCount(_tmpSuccessfulLaunchCount);
        final int _tmpFailedLaunchCount;
        _tmpFailedLaunchCount = _cursor.getInt(_cursorIndexOfFailedLaunchCount);
        _item.setFailedLaunchCount(_tmpFailedLaunchCount);
        _result.add(_item);
      }
      return _result;
    } finally {
      _cursor.close();
      _statement.release();
    }
  }

  @Override
  public List<UUID> loadAllUpdateIdsWithStatus(final UpdateStatus status) {
    final String _sql = "SELECT id FROM updates WHERE status = ?;";
    final RoomSQLiteQuery _statement = RoomSQLiteQuery.acquire(_sql, 1);
    int _argIndex = 1;
    final int _tmp = __converters.statusToInt(status);
    _statement.bindLong(_argIndex, _tmp);
    __db.assertNotSuspendingTransaction();
    final Cursor _cursor = DBUtil.query(__db, _statement, false, null);
    try {
      final List<UUID> _result = new ArrayList<UUID>(_cursor.getCount());
      while(_cursor.moveToNext()) {
        final UUID _item;
        final byte[] _tmp_1;
        if (_cursor.isNull(0)) {
          _tmp_1 = null;
        } else {
          _tmp_1 = _cursor.getBlob(0);
        }
        _item = __converters.bytesToUuid(_tmp_1);
        _result.add(_item);
      }
      return _result;
    } finally {
      _cursor.close();
      _statement.release();
    }
  }

  @Override
  public void _markUpdatesWithMissingAssets(final List<Long> missingAssetIds,
      final UpdateStatus status) {
    __db.assertNotSuspendingTransaction();
    StringBuilder _stringBuilder = StringUtil.newStringBuilder();
    _stringBuilder.append("UPDATE updates SET status = ");
    _stringBuilder.append("?");
    _stringBuilder.append(" WHERE id IN (SELECT DISTINCT update_id FROM updates_assets WHERE asset_id IN (");
    final int _inputSize = missingAssetIds.size();
    StringUtil.appendPlaceholders(_stringBuilder, _inputSize);
    _stringBuilder.append("));");
    final String _sql = _stringBuilder.toString();
    final SupportSQLiteStatement _stmt = __db.compileStatement(_sql);
    int _argIndex = 1;
    final int _tmp = __converters.statusToInt(status);
    _stmt.bindLong(_argIndex, _tmp);
    _argIndex = 2;
    for (Long _item : missingAssetIds) {
      if (_item == null) {
        _stmt.bindNull(_argIndex);
      } else {
        _stmt.bindLong(_argIndex, _item);
      }
      _argIndex ++;
    }
    __db.beginTransaction();
    try {
      _stmt.executeUpdateDelete();
      __db.setTransactionSuccessful();
    } finally {
      __db.endTransaction();
    }
  }

  public static List<Class<?>> getRequiredConverters() {
    return Collections.emptyList();
  }
}
